[["index.html", "Estimación de áreas pequeñas con el modelo multinomial Prefacio", " Estimación de áreas pequeñas con el modelo multinomial Andrés Gutiérrez, Stalyn Guerrero, Carolina Franco, Charlotte Taglioni Prefacio "],["estimación-directa-para-las-comunas-de-chile..html", "Capítulo 1 Estimación directa para las comunas de Chile.", " Capítulo 1 Estimación directa para las comunas de Chile. La Encuesta de Caracterización Socioeconómica Nacional (CASEN) de Chile 2017. Los niveles de estimación o dominios de estudio para los cuales la muestra fue representativa son: nacional, nacional urbano, nacional rural y regional. El diseño corresponde a una muestra probabilística, estratificada y bietápica, siendo los estratos conformados por la dupla Comuna-Área. La base de datos de la encuesta cuenta con 216439 registros, distribuidos en 1637 upm "],["lectura-de-la-encuesta..html", "1.1 Lectura de la encuesta.", " 1.1 Lectura de la encuesta. Para el procesamiento de la información se emplea el archivo de la encuesta disponible en los repositorios de CEPAL, las cuales han sido estandarizadas previamente. El proceso de la lectura inicia con el cargue de las siguientes librerías. TeachingSampling: Esta librería proporciona herramientas para la enseñanza y práctica de métodos de muestreo. Incluye funciones para generar diseños de muestreo, realizar muestreo aleatorio simple y estratificado, entre otros. survey: Esta librería proporciona herramientas para el análisis de datos de encuestas complejas. Permite crear y manejar diseños de muestreo, ajustar modelos estadísticos a datos de encuestas, estimar errores estándar y realizar pruebas de hipótesis. Es especialmente útil para datos de encuestas que involucren estratificación, conglomerados o ponderación. tidyverse: Esta librería es un conjunto de paquetes diseñados para trabajar juntos y facilitar la manipulación, visualización y modelado de datos en R. Incluye ggplot2 para gráficos, dplyr para manipulación de datos, tidyr para limpieza de datos, readr para lectura de datos, entre otros. srvyr: Esta librería extiende la funcionalidad de la librería survey, permitiendo el uso de la sintaxis “tidyverse” en el análisis de datos de encuestas complejas. Permite la manipulación y visualización de datos de encuestas mediante la integración con el paquete dplyr. haven: Esta librería proporciona herramientas para la lectura, escritura y manejo de datos en formato SPSS, SAS y Stata. Permite la importación y exportación de datos entre R y otros programas estadísticos, así como la manipulación de metadatos y variables etiquetadas. library(survey) library(tidyverse) library(srvyr) library(TeachingSampling) library(haven) La lectura de la base es realizada con la siguiente linea de código. encuesta &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/encuesta_2017.Rds&#39;) El siguiente código realiza una serie de transformaciones de datos utilizando el paquete tidyverse. Primero, se asigna a la variable length_upm la longitud máxima de los valores en la columna _upm de la encuesta. De manera similar, se asigna a la variable length_estrato la longitud máxima de los valores en la columna _estrato. Luego, se utiliza la función transmute() para crear nuevas variables y modificar las existentes. Se crea la variable dam (División Administrativa Mayor) a partir de la columna dam_ee, se convierte en factor y se utiliza la función str_pad() para agregar ceros a la izquierda hasta que tenga una longitud de 2 caracteres. De manera similar, se crea la variable dam2 a partir de la columna comuna, se convierte en factor y se utiliza la función str_pad() para agregar ceros a la izquierda hasta que tenga una longitud de 5 caracteres. También se crean variables nombre_dam y nombre_dam2 a partir de las mismas columnas dam_ee y comuna, respectivamente, pero se convierten en factores que utilizan los valores y etiquetas específicas. Se crea la variable upm a partir de la columna _upm, se utiliza la función str_pad() para agregar ceros a la izquierda hasta que tenga una longitud igual a length_upm. Se crea la variable estrato de manera similar a partir de la columna _estrato y utilizando length_estrato. Finalmente, se crean las variables fep y empleo, que se asignan a las columnas _fep y condact3, respectivamente. El resultado final es un conjunto de datos transformado con nuevas variables creadas y algunas columnas modificadas. ## length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string = dam, width = 2, pad = &quot;0&quot;), dam2 = as_factor(comuna,levels = &quot;values&quot;), dam2 = str_pad(string =dam2, width = 5, pad = &quot;0&quot;), nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), nombre_dam2 = as_factor(comuna,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = as_factor(condact3,levels = &quot;values&quot;), etiquetas_empleo = as_factor(condact3, levels = &quot;labels&quot;) ) head(encuesta, 10) %&gt;% tba(cap = &quot;Encuesta trasnformada&quot;) Tabla 1.1: Encuesta trasnformada dam dam2 nombre_dam nombre_dam2 upm estrato fep empleo etiquetas_empleo 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 3 Inactivo 01 01101 Tarapacá Iquique 01100100001 011001 39 -1 NA 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 2 Desocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado Realizando algunas validaciones sobre la base de datos: encuesta %&gt;% group_by( empleo, etiquetas_empleo) %&gt;% tally() %&gt;% tba(cap = &quot;Niveles de la variable empleo&quot;) Tabla 1.2: Niveles de la variable empleo empleo etiquetas_empleo n -1 NA 41363 1 Ocupado 92417 2 Desocupado 8671 3 Inactivo 73567 9 NR 421 "],["definición-del-diseño-muestral.html", "1.2 Definición del diseño muestral", " 1.2 Definición del diseño muestral El primer comando options establece una opción global para el paquete survey, que se utiliza para realizar análisis de datos con muestreo complejo. En este caso, se establece la opción survey.lonely.psu en “adjust”, lo que significa que los PSUs (unidades primarias de muestreo) solitarios se ajustarán automáticamente en los análisis. El segundo comando crea un objeto de diseño de encuesta utilizando el paquete srvyr, a partir del conjunto de datos encuesta previamente transformado. La función as_survey_design() toma varios argumentos que especifican cómo se realizó el diseño de la encuesta. En este caso, se especifica que la variable estrato se utiliza como estrato, la variable upm se utiliza como identificador de PSU, y la variable fep se utiliza como peso de muestreo. También se establece el argumento nest en TRUE para indicar que el objeto de diseño incluirá los datos anidados dentro de cada PSU. options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) "],["estimación-directa-del-indicador.html", "1.3 Estimación directa del indicador", " 1.3 Estimación directa del indicador Para realizar la estimación directa para cada dominio de la variable dam2 en el objeto de diseño diseno se emplea el siguiente código. Primero, el objeto de diseño se agrupa por la variable dam2 utilizando la función group_by_at(). Luego, se filtran las observaciones para incluir solo aquellas en las que la variable empleo es igual a 1, 2 o 3 (es decir, ocupado, desocupado o inactivo, respectivamente) utilizando la función filter(). A continuación, se utilizan las funciones sum() y unweighted para calcular el número de observaciones en cada nivel de la variable empleo. Luego, se utilizan las funciones survey_mean() para calcular la media del indicador de empleo en cada nivel de la variable empleo (es decir, la proporción de personas ocupadas, desocupadas e inactivas). Los argumentos vartype = c(\"se\", \"var\") y deff = T se utilizan para estimar el error estándar y la varianza de la media; el efecto del diseño, respectivamente. indicador_dam &lt;- diseno %&gt;% group_by_at(&quot;dam2&quot;) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( n_ocupado = unweighted(sum(empleo == 1)), n_desocupado = unweighted(sum(empleo == 2)), n_inactivo = unweighted(sum(empleo == 3)), Ocupado = survey_mean(empleo == 1, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Desocupado = survey_mean(empleo == 2, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Inactivo = survey_mean(empleo == 3, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ) ) Ahora, se realiza el conteo de las PSU por dominios y se incorpora la información a la base que resulta del paso anterior. indicador_dam &lt;- encuesta %&gt;% dplyr::select(dam2, upm) %&gt;% distinct() %&gt;% group_by(dam2) %&gt;% tally(name = &quot;n_upm&quot;) %&gt;% inner_join(indicador_dam, by = &quot;dam2&quot;) indicador_dam &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&quot;) indicador_dam %&gt;% select(dam2,n_upm,Ocupado,Desocupado,Inactivo) %&gt;% head(10) %&gt;% tba(cap = &quot;Estimación directa&quot;) Tabla 1.3: Estimación directa dam2 n_upm Ocupado Desocupado Inactivo 01101 39 0.5975 0.0478 0.3547 01107 16 0.5619 0.0539 0.3842 01401 2 0.5369 0.0499 0.4133 01402 1 0.7529 0.0000 0.2471 01404 2 0.5772 0.0095 0.4132 01405 2 0.5630 0.0188 0.4182 02101 32 0.5448 0.0557 0.3995 02102 1 0.6002 0.0680 0.3319 02103 1 0.6766 0.0838 0.2397 02104 2 0.5391 0.0576 0.4034 Guardar los archivos resultantes saveRDS(indicador_dam,&#39;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&#39; ) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["análisis-descriptivo-de-las-estimaciones-directas..html", "Capítulo 2 Análisis descriptivo de las estimaciones directas.", " Capítulo 2 Análisis descriptivo de las estimaciones directas. En la sección anterior, se llevó a cabo una estimación directa para cada categoría individualmente en cada municipio (dominio) presente en la muestra. Ahora, para evaluar la calidad de los resultados obtenidos, realizaremos un análisis descriptivo. Se emplean varias medidas de calidad, entre ellas, se cuenta el número de dominios que tienen dos o más unidades primarias de muestreo (UPM), así como el efecto de diseño mayor a 1 y las varianzas mayores a 0. Estas medidas nos permitirán determinar la fiabilidad de nuestros resultados y tomar decisiones informadas en función de ellos. "],["lectura-de-librerías.html", "2.1 Lectura de librerías", " 2.1 Lectura de librerías Las librerías que emplearemos en esta sección del código son: La librería ggplot2 es una librería de visualización de datos en R que permite crear gráficos estadísticos personalizados y de alta calidad. Ofrece una amplia variedad de opciones para crear gráficos de barras, gráficos de líneas, gráficos de dispersión, gráficos de cajas, entre otros. Esta librería se destaca por su capacidad para personalizar los gráficos en función de las necesidades del usuario, lo que permite crear gráficos complejos con múltiples capas y características. La librería dplyr es una librería utilizada para procesar y transformar datos en R. Ofrece una variedad de funciones para filtrar, ordenar, agrupar, resumir y transformar datos. Esta librería es muy útil para realizar tareas comunes de análisis de datos, como limpieza de datos, recodificación de variables, cálculo de variables derivadas, entre otras. La librería patchwork es una librería utilizada para crear paneles de visualización personalizados y complejos en R. Ofrece una amplia variedad de opciones para combinar y organizar gráficos, así como para agregar anotaciones y elementos decorativos. Esta librería es especialmente útil para crear paneles de visualización que incluyan varios gráficos y tablas. La librería kableExtra es una librería utilizada para crear tablas personalizadas y estilizadas en R. Ofrece una amplia variedad de opciones para personalizar el formato de las tablas, incluyendo la capacidad de agregar estilos y colores, resaltar celdas específicas, agregar pies de página, y mucho más. library(ggplot2) library(dplyr) library(patchwork) library(kableExtra) select &lt;- dplyr::select "],["definiendo-algunas-funciones..html", "2.2 Definiendo algunas funciones.", " 2.2 Definiendo algunas funciones. La función NAs_deff(x) cuenta la cantidad de valores NAs en un vector x. La función cont_deff() realiza el conteo del número de elementos en un vector x que son mayores a 1 y devuelve el resultado en la variable deff. La función cont_deff_upm() realiza un conteo similar al de la función cont_deff(), pero solo considera los elementos que también cumplen con la condición de que el número de unidades primarias de muestreo (UPM) es mayor o igual a 2. La función var_conteo() regresa el porcentaje de elementos que son mayores a 1 en un ventor de x NAs_deff &lt;- function(x){(sum(is.na(x))/length(x))*100} cont_deff &lt;- function(x){deff = (sum(x&gt;1,na.rm = TRUE)/length(x))*100} cont_deff_upm &lt;- function(x, nupm) { deff = (sum(x &gt; 1 &amp; nupm &gt;= 2, na.rm = TRUE)/length(x))*100 } var_conteo &lt;- function(x)(sum(x&gt;0)/length(x))*100 "],["lectura-de-las-estimaciones-directas.html", "2.3 Lectura de las estimaciones directas", " 2.3 Lectura de las estimaciones directas El siguiente comando lee los resultados de las estimaciones directas y sus medidas de calidad para cada domino, los cules fueron calculados previamente. indicador_dam &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&#39;) "],["descriptivo-de-las-estimaciones-directas.html", "2.4 Descriptivo de las estimaciones directas", " 2.4 Descriptivo de las estimaciones directas A continuación se realiza el computo de algunos medidas de resumen para las estimaciones directas, estas medidas serán empleadas para indagar por la calidad de los resultados obtenidos. 2.4.1 Conteo de los dominios con deff no estimados indicador_dam %&gt;% summarise_at(.vars = vars(matches(&quot;_deff&quot;)), NAs_deff) %&gt;% tba() Ocupado_deff Desocupado_deff Inactivo_deff 0 1.5432 0 Los resultados muestran que el \\(1.5\\%\\) de los dominios no fue posible estimar el Deff de la categoría de Desocupados. 2.4.2 Conteo de los dominios con deff mayores que 1 indicador_dam %&gt;% summarise_at(.vars =vars( matches(&quot;_deff&quot;)), cont_deff) %&gt;% tba() Ocupado_deff Desocupado_deff Inactivo_deff 47.2222 41.358 50 La tabla muestra que un \\(50\\%\\) o menos de los dominios tienen un Deff mayores que 1. 2.4.3 Porcentaje de dominios con estimación de la varianza mayor a 0 indicador_dam %&gt;% summarise_at(.vars = vars( matches(&quot;_var&quot;)), var_conteo) %&gt;% tba() Ocupado_var Desocupado_var Inactivo_var 100 98.4568 99.6914 El número de dominios con 2 o más upm {r sum(indicador_dam$n_upm&gt;=2)} 2.4.4 Conteo de dominios con dos o más upm y deff mayor 1 simultáneamente. indicador_dam %&gt;% summarise_at( .vars = vars(matches(&quot;_deff&quot;)), cont_deff_upm , nupm = indicador_dam$n_upm ) %&gt;% tba() Ocupado_deff Desocupado_deff Inactivo_deff 47.2222 41.358 50 2.4.5 Selección de los dominios que empleamos en el modelo de área. Despues de realizar las validaciones anteriores se establece como regla incluir en el estudio los dominios que posean - Dos o más upm por dominio. - Contar con un resultado en el Deff Los resultados nos deja con una base de 309 dominios (309 comunas) indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2, !is.na(Desocupado_deff)) 2.4.6 Guardar archivos saveRDS(object = indicador_dam1, &quot;01 Modelo de area/CHL/2017/Data/base_modelo.Rds&quot;) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["estimación-del-modelo-de-área-de-respuesta-multinomial.html", "Capítulo 3 Estimación del modelo de área de respuesta multinomial", " Capítulo 3 Estimación del modelo de área de respuesta multinomial La Estimación del modelo de área de respuesta multinomial es una técnica estadística utilizada para analizar datos provenientes de encuestas que involucran múltiples categorías de respuesta y están diseñadas a nivel de áreas geográficas. Esta técnica es una extensión del modelo de área de respuesta binomial, el cual se utiliza para analizar encuestas con dos posibles respuestas. El Modelo multinomial logístico es un tipo de modelo de regresión utilizado para analizar datos de respuesta categóricos que tienen más de dos categorías. Este modelo es una extensión del modelo de regresión logística binaria, el cual se utiliza para analizar datos de respuesta binaria. "],["lectura-de-librerías-1.html", "3.1 Lectura de librerías", " 3.1 Lectura de librerías La librería survey es una herramienta de análisis de datos que se utiliza para realizar análisis estadísticos de encuestas y estudios de muestreo complejos. Esta librería proporciona una variedad de herramientas para realizar análisis de regresión, estimaciones de varianza y diseño de muestras. La librería srvyr es una librería de R que permite trabajar con datos de encuestas en el formato de data.frames de la librería dplyr. Esta librería es especialmente útil para realizar análisis de encuestas y muestras complejas utilizando la sintaxis de dplyr. La librería stringr es una librería de R que proporciona herramientas para manipular y procesar cadenas de caracteres. Esta librería es especialmente útil para limpiar y transformar datos de texto. La librería magrittr es una librería de R que proporciona una sintaxis más legible y fácil de usar para encadenar y componer funciones. Esta librería es especialmente útil para escribir código más limpio y fácil de entender. La librería ggplot2 es una herramienta de visualización de datos en R que permite crear gráficos estadísticos personalizados y de alta calidad. Ofrece una amplia variedad de opciones para crear gráficos de barras, gráficos de líneas, gráficos de dispersión, gráficos de cajas, entre otros. Esta librería se destaca por su capacidad para personalizar los gráficos en función de las necesidades del usuario, lo que permite crear gráficos complejos con múltiples capas y características. La librería patchwork es una librería utilizada para crear paneles de visualización personalizados y complejos en R. Ofrece una amplia variedad de opciones para combinar y organizar gráficos, así como para agregar anotaciones y elementos decorativos. Esta librería es especialmente útil para crear paneles de visualización que incluyan varios gráficos y tablas. La librería tidyverse es una colección de paquetes de R que se utilizan para manipular, procesar y visualizar datos de manera eficiente. Incluye varias librerías como dplyr, ggplot2, tidyr, entre otras, que proporcionan herramientas para limpiar, transformar y visualizar datos de manera efectiva. - La librería *bayesplot* es una librería de visualización de datos que proporciona herramientas para crear gráficos estadísticos y diagnosticar modelos Bayesianos. Esta librería es especialmente útil para explorar la distribución posterior y evaluar la calidad del ajuste del modelo. library(survey) library(srvyr) library(stringr) library(magrittr) library(ggplot2) library(patchwork) library(tidyverse) library(rstan) library(bayesplot) select &lt;- dplyr::select 3.1.1 Lectura de bases de datos El archivo base_modelo.Rds ubicado en la ruta 01 Modelo de area/CHL/2017/Data/ es leído utilizando la función readRDS() y se asigna a la variable indicador_dam. Este archivo contiene la información de las estimaciones directas por dominios. El archivo satelitales_media.rds ubicado en la ruta 01 Modelo de area/CHL/2017/Data/ es leído utilizando la función readRDS() y se asigna a la variable statelevel_predictors_df. Este archivo contiene los datos de variables a nivel estatal que se utilizarán como predictores en el modelo de área. indicador_dam &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/base_modelo.Rds&#39;) statelevel_predictors_df &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/satelitales_media.rds&#39;) después de la lectura se realiza la estandarización de las variables para controlar el efecto de la escala. statelevel_predictors_df %&lt;&gt;% mutate_if(is.numeric, function(x)as.numeric(scale(x))) "],["realizando-ajuste-sobre-el-deff-estimado..html", "3.2 Realizando ajuste sobre el deff estimado.", " 3.2 Realizando ajuste sobre el deff estimado. Este código utiliza la librería dplyr para modificar el objeto indicador_dam y crear una nueva variable id_orden, que indica el número de orden de cada observación dentro del conjunto de datos. Además, se utiliza la función mutate() para modificar los valores de tres variables específicas (Ocupado_deff, Desocupado_deff e Inactivo_deff) del conjunto de datos indicador_dam. Estas variables el efecto de diseño para cada categoría de ocupación en la encuesta. La función ifelse() se utiliza para evaluar si los valores de las variables son menores que 1, y en ese caso se les asigna un valor de 1. Esto se hace para asegurarse de que el efecto de diseño no sea menor que 1 y así evitar problemas en el análisis posterior. indicador_dam1 &lt;- indicador_dam %&gt;% mutate( id_orden = 1:n(), Ocupado_deff = ifelse(Ocupado_deff &lt; 1, 1, Ocupado_deff), Desocupado_deff = ifelse(Desocupado_deff &lt; 1, 1, Desocupado_deff), Inactivo_deff = ifelse(Inactivo_deff &lt; 1, 1, Inactivo_deff) ) "],["definición-del-modelo-multinomial.html", "3.3 Definición del modelo multinomial", " 3.3 Definición del modelo multinomial Sea \\(K\\) el número de categorías de la variable de interés \\(\\sim multinimial\\left(\\boldsymbol{\\theta}\\right)\\), con \\(\\boldsymbol{\\theta}=\\left(p_{1},p_{2},\\dots ,p_{k}\\right)\\) y \\(\\sum_{k=1}^{K}p_{k}=1\\). Sea \\(N_i\\) el número de elementos en el i-ésiamo dominio y \\(N_{ik}\\) el número de elementos que tienen la k-ésima categoría, note que \\(\\sum_{k=1}^{K}N_{ik}=N_{i}\\) y \\(p_{ik}=\\frac{N_{ik}}{N_{i}}\\). Sea \\(\\hat{p}_{ik}\\) la estimación directa de \\(p_{ik}\\) y \\(v_{ik}=Var\\left(\\hat{p}_{ik}\\right)\\) y denote el estimador de la varianza por \\(\\hat{v}_{ik}=\\widehat{Var}\\left(\\hat{p}_{ik}\\right)\\) Note que el efecto diseño cambia entre categoría, por tanto, lo primero será definir el tamaño de muestra efectivo por categoría. Esto es: La estimación de \\(\\tilde{n}\\) esta dado por \\(\\tilde{n}_{ik} = \\frac{(\\tilde{p}_{ik}\\times(1-\\tilde{p}_{ik}))}{\\hat{v}_{ik}},\\) \\(\\tilde{y}_{ik}=\\tilde{n}_{ik}\\times\\hat{p}_{ik}\\) luego, \\(\\hat{n}_{i} = \\sum_{k=1}^{K}\\tilde{y}_{ik}\\) de donde se sigue que \\(\\hat{y}_{ik} = \\hat{n}_i\\times \\hat{p}_{ik}\\) Sea \\(\\boldsymbol{\\theta}=\\left(p_{1},p_{2}, p_{3}\\right)^{T}=\\left(\\frac{N_{i1}}{N_{i}},\\frac{N_{i2}}{N_{i}}\\frac{N_{i3}}{N_{i}}\\right)^{T}\\), entonces el modelo multinomial para el i-ésimo dominio estaría dado por: \\[ \\left(\\tilde{y}_{i1},\\tilde{y}_{i2},\\tilde{y}_{i3}\\right)\\mid\\hat{n}_{i},\\boldsymbol{\\theta}_{i}\\sim multinomial\\left(\\hat{n}_{i},\\boldsymbol{\\theta}_{i}\\right) \\] Ahora, puede escribir \\(p_{ik}\\) como : \\(\\ln\\left(\\frac{p_{i2}}{p_{i1}}\\right)=\\boldsymbol{X}_{i}^{T}\\beta_{2} + u_{i2}\\) y \\(\\ln\\left(\\frac{p_{i3}}{p_{i1}}\\right)=\\boldsymbol{X}_{i}^{T}\\beta_{3}+ u_{i3}\\) Dada la restricción \\(1 = p_{i1} + p_{i2} + p_{i3}\\) entonces \\[p_{i1} + p_{i1}(e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2})+p_{i1}(e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta}_{3}} + u_{i3})\\] de donde se sigue que \\[ p_{i1}=\\frac{1}{1+e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2}+e^{\\boldsymbol{X_{i}}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i3}} \\] Las expresiones para \\(p_{i2}\\) y \\(p_{i3}\\) estarían dadas por: \\[ p_{i2}=\\frac{e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta}_{2}} + u_{i2}}{1+e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2}+e^{\\boldsymbol{X_{i}}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i3}} \\] \\[ p_{i3}=\\frac{e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta}_{3}}+ u_{i3}}{1+e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2}+e^{\\boldsymbol{X_{i}}^{T}\\boldsymbol{\\beta_{3}}}+ u_{i3}} \\] dado la naturaleza de la variable, se puede suponer que \\(cor(u_{i2},u_{i3})\\ne 0\\) "],["modelo-programando-en-stan.html", "3.4 Modelo programando en STAN", " 3.4 Modelo programando en STAN El código presenta la implementación de un modelo multinomial logístico de área de respuesta utilizando el lenguaje de programación STAN. En este modelo, se asume que la variable de respuesta en cada dominio sigue una distribución multinomial con una estructura de correlación desconocida entre las diferentes categorías. Además, se asume que los parámetros que rigen la relación entre las variables predictoras y la variable de respuesta son diferentes en cada dominio y se modelan como efectos aleatorios. La sección de functions define una función auxiliar llamada pred_theta(), que se utiliza para predecir los valores de la variable de respuesta en los dominios no observados. La sección de data contiene las variables de entrada del modelo, incluyendo el número de dominios, el número de categorías de la variable de respuesta, las estimaciones directas de la variable de respuesta en cada dominio, las covariables observadas en cada dominio y las covariables correspondientes a los dominios no observados. La sección de parameters define los parámetros desconocidos del modelo, incluyendo la matriz de parámetros beta, que contiene los coeficientes que relacionan las covariables con la variable de respuesta en cada categoría. También se incluyen los desviaciones estándar de los efectos aleatorios, la matriz de correlación entre los efectos aleatorios y la matriz de efectos aleatorios en sí. En la sección de transformed parameters se define el vector de parámetros theta, que contiene las probabilidades de pertenencia a cada categoría de la variable de respuesta en cada dominio. Se utilizan los efectos aleatorios para ajustar los valores de theta en cada dominio. En la sección de model se define la estructura del modelo y se incluyen las distribuciones a priori para los parámetros desconocidos. En particular, se utiliza una distribución normal para los coeficientes de la matriz beta y una distribución LKJ para la matriz de correlación entre los efectos aleatorios. Finalmente, se calcula la función de verosimilitud de la distribución multinomial para las estimaciones directas de la variable de respuesta en cada dominio. La sección de generated quantities se utiliza para calcular las predicciones de la variable de respuesta en los dominios no observados utilizando la función auxiliar definida previamente. También se calcula la matriz de correlación entre los efectos aleatorios. functions { matrix pred_theta(matrix Xp, int p, matrix beta){ int D1 = rows(Xp); real num1[D1, p]; real den1[D1]; matrix[D1,p] theta_p; for(d in 1:D1){ num1[d, 1] = 1; num1[d, 2] = exp(Xp[d, ] * beta[1, ]&#39; ) ; num1[d, 3] = exp(Xp[d, ] * beta[2, ]&#39; ) ; den1[d] = sum(num1[d, ]); } for(d in 1:D1){ for(i in 2:p){ theta_p[d, i] = num1[d, i]/den1[d]; } theta_p[d, 1] = 1/den1[d]; } return theta_p ; } } data { int&lt;lower=1&gt; D; // número de dominios int&lt;lower=1&gt; P; // categorías int&lt;lower=1&gt; K; // cantidad de regresores int hat_y[D, P]; // estimaciones directa matrix[D, K] X_obs; // matriz de covariables int&lt;lower=1&gt; D1; // número de dominios no observados matrix[D1, K] X_pred; // matriz de covariables para los no observados } parameters { matrix[P-1, K] beta;// matriz de parámetros vector&lt;lower=0&gt;[P-1] sigma_u; // random effects standard deviations // declare L_u to be the Choleski factor of a 2x2 correlation matrix cholesky_factor_corr[P-1] L_u; matrix[P-1, D] z_u; } transformed parameters { simplex[P] theta[D];// vector de parámetros; real num[D, P]; real den[D]; // this transform random effects so that they have the correlation // matrix specified by the correlation matrix above matrix[P-1, D] u; // random effect matrix u = diag_pre_multiply(sigma_u, L_u) * z_u; for(d in 1:D){ num[d, 1] = 1; num[d, 2] = exp(X_obs[d, ] * beta[1, ]&#39; + u[1, d]) ; num[d, 3] = exp(X_obs[d, ] * beta[2, ]&#39; + u[2, d]) ; den[d] = sum(num[d, ]); } for(d in 1:D){ for(p in 2:P){ theta[d, p] = num[d, p]/den[d]; } theta[d, 1] = 1/den[d]; } } model { L_u ~ lkj_corr_cholesky(1); // LKJ prior for the correlation matrix to_vector(z_u) ~ normal(0, 10000); // sigma_u ~ cauchy(0, 50); sigma_u ~ inv_gamma(0.0001, 0.0001); for(p in 2:P){ for(k in 1:K){ beta[p-1, k] ~ normal(0, 10000); } } for(d in 1:D){ target += multinomial_lpmf(hat_y[d, ] | theta[d, ]); } } generated quantities { matrix[D1,P] theta_pred; matrix[2, 2] Omega; Omega = L_u * L_u&#39;; // so that it return the correlation matrix theta_pred = pred_theta(X_pred, P, beta); } "],["identificando-los-municipios-para-predicción.html", "3.5 Identificando los municipios para predicción", " 3.5 Identificando los municipios para predicción X_pred &lt;- anti_join(statelevel_predictors_df, indicador_dam1 %&gt;% select(dam2)) Guardar el identificador de municipio a predecir. X_pred %&gt;% select(dam2) %&gt;% saveRDS(file = &quot;01 Modelo de area/CHL/2017/Data/dam_pred.rds&quot;) "],["obteniendo-la-matriz.html", "3.6 Obteniendo la matriz", " 3.6 Obteniendo la matriz X_pred %&lt;&gt;% data.frame() %&gt;% select(-dam2) %&gt;% as.matrix() "],["identificando-los-dominios-para-realizar-estimación-del-modelo.html", "3.7 Identificando los dominios para realizar estimación del modelo", " 3.7 Identificando los dominios para realizar estimación del modelo El código siguiente realiza una serie de operaciones con dos conjuntos de datos: indicador_dam1 y statelevel_predictors_df. En primer lugar, utiliza la función inner_join() de dplyr para unir ambos data.frames por la columna id_orden. Luego, se ordenan las filas por esta misma columna y se eliminan las columnas dam2 e id_orden. Finalmente, se convierte el resultado en una matriz y se asigna a la variable X_obs. En resumen, este código prepara los datos para ser utilizados en un modelo de regresión logística multinomial de área de respuesta. X_obs &lt;- inner_join(indicador_dam1 %&gt;% select(dam2, id_orden), statelevel_predictors_df) %&gt;% arrange(id_orden) %&gt;% data.frame() %&gt;% select(-dam2, -id_orden) %&gt;% as.matrix() "],["identificando-los-argumentos-para-stan.html", "3.8 Identificando los argumentos para STAN", " 3.8 Identificando los argumentos para STAN Creando \\(\\tilde{y}\\), \\(\\tilde{n}\\) y \\(\\hat{y}\\) D &lt;- nrow(indicador_dam1) P &lt;- 3 # Ocupado, desocupado, inactivo. Y_tilde &lt;- matrix(NA, D, P) n_tilde &lt;- matrix(NA, D, P) Y_hat &lt;- matrix(NA, D, P) Realizando los calculos necesarios para cada categoria. # n efectivos ocupado n_tilde[,1] &lt;- (indicador_dam1$Ocupado*(1 - indicador_dam1$Ocupado))/indicador_dam1$Ocupado_var Y_tilde[,1] &lt;- n_tilde[,1]* indicador_dam1$Ocupado # n efectivos desocupado n_tilde[,2] &lt;- (indicador_dam1$Desocupado*(1 - indicador_dam1$Desocupado))/indicador_dam1$Desocupado_var Y_tilde[,2] &lt;- n_tilde[,2]* indicador_dam1$Desocupado # n efectivos Inactivo n_tilde[,3] &lt;- (indicador_dam1$Inactivo*(1 - indicador_dam1$Inactivo))/indicador_dam1$Inactivo_var Y_tilde[,3] &lt;- n_tilde[,3]* indicador_dam1$Inactivo Calculando \\(\\hat{y}\\) ni_hat = rowSums(Y_tilde) Y_hat[,1] &lt;- ni_hat* indicador_dam1$Ocupado Y_hat[,2] &lt;- ni_hat* indicador_dam1$Desocupado Y_hat[,3] &lt;- ni_hat* indicador_dam1$Inactivo Para realizar la validación de los calculos construimos el siguiente gráfico. hat_p &lt;- Y_hat/rowSums(Y_hat) par(mfrow = c(1,3)) plot(hat_p[,1],indicador_dam1$Ocupado, main = &quot;Ocupado&quot;, xlab = &quot;hat_p&quot;, ylab = &quot;Estimacion directa&quot;) ## Error : The fig.showtext code chunk option must be TRUE plot(hat_p[,2],indicador_dam1$Desocupado, main = &quot;Desocupado&quot;, xlab = &quot;hat_p&quot;, ylab = &quot;Estimacion directa&quot;) ## Error : The fig.showtext code chunk option must be TRUE plot(hat_p[,3],indicador_dam1$Inactivo,main = &quot;Inactivo&quot;, xlab = &quot;hat_p&quot;, ylab = &quot;Estimacion directa&quot;) ## Error : The fig.showtext code chunk option must be TRUE ahora, la correlación de las covariables y las estimaciones directas rr &lt;- cor(hat_p,X_obs) %&gt;% data.frame() row.names(rr)&lt;- c(&quot;Ocupado&quot;, &quot;Desocupado&quot;, &quot;Inactivo&quot;) tba(rr) luces_nocturnas cubrimiento_cultivo cubrimiento_urbano modificacion_humana accesibilidad_hospitales accesibilidad_hosp_caminado Ocupado 0.4920 -0.1208 0.4485 0.2944 0.1127 0.0923 Desocupado 0.1402 -0.1097 0.1098 0.1228 -0.0765 -0.0944 Inactivo -0.5401 0.1550 -0.4869 -0.3347 -0.0915 -0.0655 Agregando el intercepto a la matriz de covariables X1_obs &lt;- cbind(matrix(1,nrow = D,ncol = 1),X_obs) K = ncol(X1_obs) D1 &lt;- nrow(X_pred) X1_pred &lt;- cbind(matrix(1,nrow = D1,ncol = 1),X_pred) 3.8.1 Preparando argumentos para STAN El código siguiente crea un objeto de lista llamado sample_data que contiene los datos necesarios para estimar el modelo de área de respuesta multinomial. La lista incluye el número total de dominios (D), el número de categorías (P), la cantidad de covariables (K), las estimaciones directas de las categorías en cada dominio (hat_y), la matriz de covariables de los dominios observados (X_obs), la matriz de covariables de los dominios no observados (X_pred) y el número de dominios no observados (D1). Este objeto de lista será utilizado posteriormente en la estimación del modelo utilizando la función stan. sample_data &lt;- list(D = D, P = P, K = K, hat_y = Y_hat, X_obs = X1_obs, X_pred = X1_pred, D1 = D1) 3.8.2 Ejecutando el modelo en STAN Este código ejecuta el muestreo MCMC utilizando el modelo especificado en fit2, con un número de iteraciones de muestreo y calentamiento de 2000 cada uno, y utilizando los datos en sample_data. También especifica una semilla de 123 para reproducibilidad y ejecuta cuatro cadenas paralelas en cuatro núcleos. El resultado es una lista fit_mcmc2 que contiene los valores muestreados de los parámetros del modelo y otros diagnósticos del muestreo. fit_mcmc2 &lt;- stan( file = &quot;01 Modelo de area/0funciones/01 Multinomial_simple_pred.stan&quot;, # Stan program data = sample_data, # named list of data # chains = 4, # number of Markov chains verbose = TRUE, warmup = 2000, # number of warmup iterations per chain iter = 4000, # total number of iterations per chain cores = 4, # number of cores (could use one per chain) # refresh = 0 # no progress shown ) Guardando el modelo saveRDS(fit_mcmc2, &quot;01 Modelo de area/CHL/2017/Data/fit_multinomial_con_covariable.Rds&quot;) leer el modelo previamente ejecutado fit_mcmc2 &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/fit_multinomial_con_covariable.Rds&quot;) 3.8.3 Valores estimados para beta summary(fit_mcmc2, pars = &quot;beta&quot;)$summary %&gt;% as.data.frame() %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat beta[1,1] -3.2887 0.0026 0.1005 -3.4856 -3.3565 -3.2888 -3.2228 -3.0899 1550.456 1.0022 beta[1,2] -0.0324 0.0018 0.0749 -0.1792 -0.0827 -0.0328 0.0200 0.1124 1732.077 1.0018 beta[1,3] -0.1460 0.0011 0.0428 -0.2292 -0.1752 -0.1468 -0.1166 -0.0624 1459.259 1.0027 beta[1,4] -0.1329 0.0014 0.0633 -0.2567 -0.1755 -0.1335 -0.0906 -0.0073 1942.175 1.0018 beta[1,5] 0.1987 0.0020 0.0727 0.0557 0.1489 0.1985 0.2490 0.3385 1385.171 1.0032 beta[1,6] 12.2961 0.0346 1.3589 9.5827 11.4018 12.2943 13.1933 14.9532 1541.759 1.0021 beta[2,1] -0.4829 0.0016 0.0502 -0.5807 -0.5173 -0.4840 -0.4487 -0.3828 1009.085 1.0027 beta[2,2] -0.2249 0.0010 0.0375 -0.2991 -0.2496 -0.2247 -0.2001 -0.1492 1425.482 1.0021 beta[2,3] -0.0249 0.0006 0.0212 -0.0665 -0.0393 -0.0246 -0.0103 0.0165 1237.445 1.0026 beta[2,4] 0.0041 0.0008 0.0309 -0.0570 -0.0170 0.0042 0.0253 0.0642 1682.866 1.0047 beta[2,5] 0.1075 0.0011 0.0364 0.0372 0.0824 0.1074 0.1322 0.1789 1147.132 1.0009 beta[2,6] 4.8313 0.0212 0.6851 3.4469 4.3705 4.8426 5.3007 6.1660 1048.115 1.0027 3.8.4 Valores estimados para la matriz de correlación summary(fit_mcmc2, pars = &quot;Omega&quot;)$summary %&gt;% as.data.frame() %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat Omega[1,1] 1.00 NaN 0.0000 1.0000 1.0000 1.0000 1.0000 1.0000 NaN NaN Omega[1,2] 0.17 0.0024 0.0723 0.0262 0.1222 0.1701 0.2194 0.3066 914.0926 1.0004 Omega[2,1] 0.17 0.0024 0.0723 0.0262 0.1222 0.1701 0.2194 0.3066 914.0926 1.0004 Omega[2,2] 1.00 0.0000 0.0000 1.0000 1.0000 1.0000 1.0000 1.0000 7803.8115 0.9995 3.8.5 Validación dela convergencia de las cadenas valores cercanos a 1 indica que las cadenas hicieron convergencia. a &lt;- as.data.frame(summary(fit_mcmc2)$summary)$Rhat mcmc_rhat_hist(a, bins = 30) 3.8.6 Evaluación visual de las cadenas para beta El código dado genera un gráfico de densidad (mcmc_dens_chains), un gráfico de áreas (mcmc_areas) y un gráfico de traza (mcmc_trace) para cada parámetro en la matriz “beta” en la salida del modelo de MCMC “fit_mcmc2”. Los gráficos de densidad y de áreas muestran la distribución posterior de cada parámetro en la matriz “beta” para cada cadena del modelo. posterior_beta &lt;- as.array(fit_mcmc2, pars = &quot;beta&quot;) (mcmc_dens_chains(posterior_beta) + mcmc_areas(posterior_beta) ) / mcmc_trace(posterior_beta) 3.8.7 extrayendo las estimaciones para theta theta_temp &lt;- summary(fit_mcmc2, pars = &quot;theta&quot;)$summary[, &quot;mean&quot;] theta_temp_pred &lt;- summary(fit_mcmc2, pars = &quot;theta_pred&quot;)$summary[, &quot;mean&quot;] 3.8.8 Organizando los resultados en una matriz. La primera parte del código crea una matriz theta_fh” de dimensiones D x P, en la que se colocan los valores medios de theta_temp. Los argumentos nrow y ncol definen las filas y columnas de la matriz, mientras que byrow establece que los valores se colocan por columnas. Luego se utiliza la función rowSums() para sumar los valores por filas. El segundo bloque de código es similar al primero, pero crea una matriz theta_fh_pred de dimensiones D1 x P, con los valores medios de theta_temp_pred. Luego se utiliza la función rowSums para sumar los valores por filas. theta_fh &lt;- matrix(theta_temp, nrow = D,ncol = P,byrow = TRUE) theta_fh_pred &lt;- matrix(theta_temp_pred, nrow = D1,ncol = P,byrow = TRUE) 3.8.9 Preparando el gráfico comparativo entre la estimación dir y el modelo par(mfrow = c(1,3)) plot(theta_fh[,1],indicador_dam1$Ocupado) abline(a = 0,b = 1, col = &quot;red&quot;) plot(theta_fh[,2],indicador_dam1$Desocupado) abline(a = 0,b = 1, col = &quot;red&quot;) plot(theta_fh[,3],indicador_dam1$Inactivo) abline(a = 0,b = 1, col = &quot;red&quot;) 3.8.10 Preparando el ppc En el siguiente código se utiliza para realizar una validación cruzada predictiva (PPC, por las siglas en inglés) en los datos de prueba. Primero, se extraen las muestras de la distribución posterior predictiva para las variables \\(\\theta\\) (y_pred_B). Luego, se seleccionan aleatoriamente 500 filas de y_pred_B. A continuación, se separan las columnas de y_pred_B correspondientes a cada categoría de ocupación (Ocupado, Desocupado, Inactivo) y se crean los vectores y_pred1, y_pred2 y y_pred3, respectivamente. Finalmente, se utiliza la función ppc_dens_overlay() para graficar la densidad de las predicciones en cada categoría y compararlas con los datos observados correspondientes. posterior_theta &lt;- as.array(fit_mcmc2, pars = &quot;theta&quot;) dim(posterior_theta) rowsrandom &lt;- sample(dim(posterior_theta)[1], 50) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = dimnames(posterior_theta)$parameters,value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = dimnames(posterior_theta)$parameters,value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = dimnames(posterior_theta)$parameters,value = TRUE) y_pred1 &lt;- posterior_theta[rowsrandom, , theta_1 ] y_pred2 &lt;- posterior_theta[rowsrandom, , theta_2 ] y_pred3 &lt;- posterior_theta[rowsrandom, , theta_3 ] ppc_dens_overlay(y = as.numeric(indicador_dam1$Ocupado), matrix(y_pred1, ncol = length(theta_1)))/ ppc_dens_overlay(y = as.numeric(indicador_dam1$Desocupado), matrix(y_pred2, ncol = length(theta_1)))/ ppc_dens_overlay(y = as.numeric(indicador_dam1$Inactivo), matrix(y_pred3, ncol = length(theta_1))) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["validación-sobre-los-resultados-del-modelo-de-área..html", "Capítulo 4 Validación sobre los resultados del modelo de área.", " Capítulo 4 Validación sobre los resultados del modelo de área. La validación de un modelo es esencial para evaluar su capacidad para predecir de manera precisa y confiable los resultados futuros. En el caso de un modelo de área con respuesta multinomial, la validación se enfoca en medir la precisión del modelo para predecir las diferentes categorías de respuesta. El objetivo principal de la validación es determinar si el modelo es capaz de generalizar bien a datos no vistos y proporcionar predicciones precisas. Esto implica comparar las predicciones del modelo con los datos observados y utilizar métricas de evaluación para medir el rendimiento del modelo. La validación del modelo es esencial para garantizar la calidad de las predicciones y la confiabilidad del modelo para su uso en aplicaciones futuras. "],["lectura-de-librerías-2.html", "4.1 Lectura de librerías", " 4.1 Lectura de librerías La librería stringr es una librería de R que proporciona herramientas para manipular y procesar cadenas de caracteres. Esta librería es especialmente útil para limpiar y transformar datos de texto. La librería magrittr es una librería de R que proporciona una sintaxis más legible y fácil de usar para encadenar y componer funciones. Esta librería es especialmente útil para escribir código más limpio y fácil de entender. La librería ggplot2 es una herramienta de visualización de datos en R que permite crear gráficos estadísticos personalizados y de alta calidad. Ofrece una amplia variedad de opciones para crear gráficos de barras, gráficos de líneas, gráficos de dispersión, gráficos de cajas, entre otros. Esta librería se destaca por su capacidad para personalizar los gráficos en función de las necesidades del usuario, lo que permite crear gráficos complejos con múltiples capas y características. La librería patchwork es una librería utilizada para crear paneles de visualización personalizados y complejos en R. Ofrece una amplia variedad de opciones para combinar y organizar gráficos, así como para agregar anotaciones y elementos decorativos. Esta librería es especialmente útil para crear paneles de visualización que incluyan varios gráficos y tablas. La librería tidyverse es una colección de paquetes de R que se utilizan para manipular, procesar y visualizar datos de manera eficiente. Incluye varias librerías como dplyr, ggplot2, tidyr, entre otras, que proporcionan herramientas para limpiar, transformar y visualizar datos de manera efectiva. La librería forcats es una herramienta de manipulación de factores en R. Proporciona una serie de funciones para trabajar con variables categóricas/factores y manejarlos de manera más eficiente y efectiva. La librería bayesplot es una librería de visualización de datos que proporciona herramientas para crear gráficos estadísticos y diagnosticar modelos Bayesianos. Esta librería es especialmente útil para explorar la distribución posterior y evaluar la calidad del ajuste del modelo. library(stringr) library(magrittr) library(ggplot2) library(patchwork) library(tidyverse) library(forcats) library(rstan) library(bayesplot) select &lt;- dplyr::select "],["lectura-de-bases-de-datos-1.html", "4.2 Lectura de bases de datos", " 4.2 Lectura de bases de datos Estas dos líneas de código están leyendo archivos RDS en el directorio especificado. El archivo indicador_dam.Rds contiene un conjunto de datos llamado indicador_dam que se utilizará para ajustar y validar el modelo. El archivo dam_pred.rds contiene datos adicionales para realizar predicciones fuera de la muestra y evaluar el desempeño del modelo. indicador_dam &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&#39;) dam_pred &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/dam_pred.rds&#39;) Además, el siguiente bloque de código establece el nombre del modelo (mod) y crea dos variables que especifican la ubicación del archivo de entrada (infile) y el archivo de salida (out_estimacion) para las estimaciones del modelo. Finalmente, el código utiliza la función readRDS() para cargar el modelo ajustado previamente en el archivo de entrada infile y asignarlo a la variable fit. mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/&quot;,mod,&quot;.rds&quot;) out_estimacion &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_&quot;,mod,&quot;.rds&quot;) fit &lt;- readRDS(infile) "],["estimacion-directa.html", "4.3 Estimacion directa", " 4.3 Estimacion directa En estas líneas de código se realiza una selección y transformación de datos a partir del dataset indicador_dam que se leyó previamente. Primero, se filtra el dataset para mantener solo las filas en las que el valor de n_upm (conteo de unidad primaria de muestreo) es mayor o igual a 2 y donde no haya valores faltantes en la columna Desocupado_deff. Esto se logra utilizando la función filter() de dplyr. Luego, se define el número de categorías (P) como 3, el número de dominios (D) como el número de filas en el dataset filtrado indicador_dam1, y el número de dominios de predicción (D1) como el número de filas en el dataset dam_pred que se leyó previamente. Finalmente, se crea un nuevo dataframe theta_dir a partir del data.frame filtrado indicador_dam1. Este nuevo dataframe contiene la información de n_desocupado, n_ocupado y n_inactivo de cada dominios y la categoría ocupacional de interés (Ocupado, Desocupado e Inactivo). indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2 &amp; !is.na(Desocupado_deff)) P &lt;- 3 D &lt;- nrow(indicador_dam1) D1 &lt;- nrow(dam_pred) theta_dir &lt;- indicador_dam1 %&gt;% transmute(dam2, n = n_desocupado + n_ocupado + n_inactivo, Ocupado, Desocupado, Inactivo) Ahora, se obtienen las estimaciones del parámetro \\(\\theta\\) a partir del modelo. theta_obs &lt;- summary(fit,pars = &quot;theta&quot;)$summary theta_pred &lt;- summary(fit,pars = &quot;theta_pred&quot;)$summary Seguido de esto se organiza la matriz de \\(\\theta\\) El código crea dos matrices, theta_obs_ordenado y theta_pred_ordenado, que contienen las estimaciones medias de los parámetros del modelo de respuesta multinomial con covariables para los datos de observación y predicción, respectivamente. La función matrix() se utiliza para dar formato a los datos con una matriz nrow x ncol, y se asignan nombres de columna apropiados a la matriz resultante utilizando colnames(). Luego se convierten las matrices en marcos de datos (as.data.frame()) y se unen mediante full_join() para crear una única tabla que contenga todas las estimaciones de los parámetros para los datos de observación y predicción, junto con la información del indicador de área (theta_dir). El resultado final es un marco de datos llamado estimaciones_obs. theta_obs_ordenado &lt;- matrix(theta_obs[, &quot;mean&quot;], nrow = D, ncol = P, byrow = TRUE) colnames(theta_obs_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_obs_ordenado %&lt;&gt;% as.data.frame() theta_obs_ordenado &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado) theta_pred_ordenado &lt;- matrix(theta_pred[, &quot;mean&quot;], nrow = D1, ncol = P, byrow = TRUE) colnames(theta_pred_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_pred_ordenado %&lt;&gt;% as.data.frame() theta_pred_ordenado &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado) estimaciones_obs &lt;- full_join(theta_dir, bind_rows(theta_obs_ordenado, theta_pred_ordenado)) "],["estimación-del-coeficiente-de-variación.html", "4.4 Estimación del coeficiente de variación", " 4.4 Estimación del coeficiente de variación Este bloque de código tiene como objetivo calcular la desviación estándar (sd) y el coeficiente de variación (cv) de los parámetros estimados del modelo para las áreas de observación (theta_obs) y las áreas de predicción (theta_pred). En primer lugar, se convierten los valores de theta_obs y theta_pred en matrices y se les asignan nombres de columnas correspondientes a los tres estados laborales: Ocupado_mod, Desocupado_mod e Inactivo_mod. A continuación, se calcula la desviación estándar de cada uno de estos parámetros para las áreas de observación y se crea una nueva matriz theta_obs_ordenado_sd. De manera similar, se calcula la desviación estándar de cada parámetro para las áreas de predicción y se crea una matriz theta_pred_ordenado_sd. Posteriormente, se calcula el coeficiente de variación para cada parámetro en las áreas de observación y predicción, dividiendo la desviación estándar entre la media de cada parámetro y se crean las matrices theta_obs_ordenado_cv y theta_pred_ordenado_cv, respectivamente. Finalmente, se combinan todas las matrices en una sola llamada estimaciones_obs mediante la función cbind(). theta_obs_ordenado_sd &lt;- matrix(theta_obs[,&quot;sd&quot;], nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_obs_ordenado_sd%&lt;&gt;% as.data.frame() theta_obs_ordenado_sd &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_sd) theta_obs_ordenado_cv &lt;- theta_obs_ordenado_sd[,-1]/theta_obs_ordenado[,-1] colnames(theta_obs_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_obs_ordenado_cv &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_cv) theta_pred_ordenado_sd &lt;- matrix(theta_pred[,&quot;sd&quot;], nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_pred_ordenado_sd%&lt;&gt;% as.data.frame() theta_pred_ordenado_sd &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_sd) theta_pred_ordenado_cv &lt;- theta_pred_ordenado_sd[,-1]/theta_pred_ordenado[,-1] colnames(theta_pred_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_pred_ordenado_cv &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_cv) "],["consolidando-los-resultados-en-una-base-de-datos..html", "4.5 Consolidando los resultados en una base de datos.", " 4.5 Consolidando los resultados en una base de datos. En este fragmento de código se están uniendo los data frames theta_obs_ordenado, theta_obs_ordenado_sd y theta_obs_ordenado_cv mediante la función full_join(), y se está almacenando el resultado en el data frame theta_obs_ordenado. Lo mismo se está realizando con los data frames theta_pred_ordenado, theta_pred_ordenado_sd y theta_pred_ordenado_cv, almacenando el resultado en el data frame theta_pred_ordenado. Posteriormente, se está uniendo el data frame theta_obs_ordenado y theta_pred_ordenado con el data frame indicador_dam1, donde se están guardando las estimaciones en el data frame estimaciones_obs. theta_obs_ordenado &lt;- full_join(theta_obs_ordenado,theta_obs_ordenado_sd) %&gt;% full_join(theta_obs_ordenado_cv) theta_pred_ordenado &lt;- full_join(theta_pred_ordenado,theta_pred_ordenado_sd) %&gt;% full_join(theta_pred_ordenado_cv) estimaciones_obs &lt;- full_join(indicador_dam1, bind_rows(theta_obs_ordenado, theta_pred_ordenado)) "],["gráfica-comparativa-entre-las-estimación-directa-y-la-estimación-resultante-del-modelo.html", "4.6 Gráfica comparativa entre las estimación directa y la estimación resultante del modelo", " 4.6 Gráfica comparativa entre las estimación directa y la estimación resultante del modelo 4.6.1 Estimación puntual El código genera tres gráficos en un formato de mosaico con p_ocupado, p_Desocupado y p_Inactivo. Cada gráfico muestra la relación entre la variable dependiente de la encuesta original y la variable dependiente estimada por el modelo de área. Cada gráfico utiliza los datos de estimaciones_obs y utiliza geom_point() para agregar puntos que representan la estimación directa de la variable dependiente (y) versus la estimación por el modelo de área (x). También utiliza geom_abline() para agregar una línea roja con una pendiente de 1 e intercepto de 0, lo que representa una relación perfecta entre la variable dependiente original y la variable dependiente estimada. Finalmente, cada gráfico utiliza labs para agregar etiquetas de eje y títulos de gráfico. El tema theme_bw() establece el tema en blanco y negro con un tamaño de fuente de 20 puntos. Los tres gráficos se combinan usando el operador | para crear un mosaico. p_ocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Ocupado, x = Ocupado_mod )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Ocupado&quot;)+ theme_bw(base_size = 20) p_Desocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Desocupado, x = Desocupado_mod )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot;, title = &quot;Desocupado&quot;)+ theme_bw(base_size = 20) p_Inactivo &lt;- ggplot(data = estimaciones_obs, aes(y = Inactivo, x = Inactivo_mod )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Inactivo&quot;)+ theme_bw(base_size = 20) p_ocupado|p_Desocupado|p_Inactivo 4.6.2 Error estándar. Crea tres gráficos de dispersión utilizando el paquete ggplot2. Cada gráfico muestra la relación entre la estimación directa y la estimación del modelo de área para cada una de las tres categorías de ocupación: Ocupado, Desocupado e Inactivo. Se utiliza la función geom_point() para agregar los puntos en el gráfico y geom_abline() para dibujar una línea de referencia en cada gráfico. Se establece la etiqueta de los ejes x e y y el título de cada gráfico utilizando la función labs(). Se ajusta el tema del gráfico utilizando la función theme_bw(). Finalmente, se combinan los tres gráficos utilizando el operador + y se limita el rango del eje x para cada gráfico utilizando la función xlim(). p_ocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Ocupado_se, x = Ocupado_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Ocupado (se)&quot;)+ theme_bw(base_size = 20) p_Desocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Desocupado_se, x = Desocupado_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot;, title = &quot;Desocupado (se)&quot;)+ theme_bw(base_size = 20) p_Inactivo &lt;- ggplot(data = estimaciones_obs, aes(y = Inactivo_se, x = Inactivo_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Inactivo(se)&quot;)+ theme_bw(base_size = 20) p_ocupado + xlim(0,0.05)| p_Desocupado + xlim(0,0.05)| p_Inactivo + xlim(0,0.05) 4.6.3 Coeficiente de varianción. Este código utiliza el paquete ggplot2 en R para crear tres gráficas que comparan los coeficientes de variación (cv) estimado con las estimaciones obtenidas mediante modelos de áreas para tres categorías de empleo: ocupados, desocupados e inactivos. Las gráficas muestran la relación entre la estimación directa del y la estimación del modelo de área, donde la línea roja representa una línea diagonal perfecta. Si los puntos están cerca de la línea roja, significa que la estimación del modelo de área es similar a la estimación directa. p_ocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Ocupado_se/Ocupado, x = Ocupado_mod_cv )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Ocupado (cv)&quot;)+ theme_bw(base_size = 20) p_Desocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Desocupado_se/Desocupado, x = Desocupado_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot;, title = &quot;Desocupado(cv)&quot;)+ theme_bw(base_size = 20) p_Inactivo &lt;- ggplot(data = estimaciones_obs, aes(y = Inactivo_se/Inactivo, x = Inactivo_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Inactivo(cv)&quot;)+ theme_bw(base_size = 20) p_ocupado + xlim(0,0.1)| p_Desocupado + xlim(0,0.05)| p_Inactivo + xlim(0,0.05) Este código se utiliza para realizar una validación cruzada predictiva (PPC, por sus siglas en inglés) en un modelo estadístico que utiliza el paquete bayesplot. Primero, se establece un esquema de color para los gráficos utilizando la función color_scheme_set() y se configura un tema visual utilizando la función theme_set(). Luego, se extraen las muestras posteriores del parámetro theta del ajuste del modelo utilizando la función fit$draws(). Se seleccionan al azar 100 filas de estas muestras posteriores y se extraen los valores correspondientes a las tres categorías de empleo: Ocupado, Desocupado e Inactivo. Se calcula el PPC para cada categoría de empleo utilizando la función ppc_dens_overlay() y se superponen las densidades estimadas a partir de los datos reales y los valores predichos para visualizar la bondad del ajuste del modelo. ### Gráficos de los ppc color_scheme_set(&quot;brightblue&quot;) theme_set(theme_bw(base_size = 15)) y_pred_B &lt;- fit$draws(variables = &quot;theta&quot;, format = &quot;matrix&quot;) rowsrandom &lt;- sample(nrow(y_pred_B), 100) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = colnames(y_pred_B),value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = colnames(y_pred_B),value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = colnames(y_pred_B),value = TRUE) y_pred1 &lt;- y_pred_B[rowsrandom,theta_1 ] y_pred2 &lt;- y_pred_B[rowsrandom,theta_2 ] y_pred3 &lt;- y_pred_B[rowsrandom,theta_3 ] ppc_dens_overlay(y = as.numeric(theta_dir$Ocupado), y_pred1)/ ppc_dens_overlay(y = as.numeric(theta_dir$Desocupado), y_pred2)/ ppc_dens_overlay(y = as.numeric(theta_dir$Inactivo), y_pred3) Por ultimo se guardan los resultados obtenidos. saveRDS(object = estimaciones_obs, file = out_estimacion) rm( list = ls()) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["estimaciones-ajustadas-por-benchmark.html", "Capítulo 5 Estimaciones ajustadas por Benchmark", " Capítulo 5 Estimaciones ajustadas por Benchmark El ajuste de benchmark se puede realizar utilizando diferentes enfoques. En algunos casos, se puede utilizar información auxiliar directamente, como la información sobre la población o la información sobre la distribución de las variables de interés. En otros casos, se pueden utilizar modelos estadísticos para relacionar las variables auxiliares y las variables de interés en las áreas pequeñas y grandes. "],["lectura-de-librerías-3.html", "5.1 Lectura de librerías", " 5.1 Lectura de librerías library(survey) library(tidyverse) library(srvyr) library(TeachingSampling) library(haven) library(sampling) "],["lectura-de-las-bases-de-datos.html", "5.2 Lectura de las bases de datos", " 5.2 Lectura de las bases de datos encuesta &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/encuesta_2017.Rds&quot;) 5.2.1 Parametrizando el código mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_&quot;,mod,&quot;.rds&quot;) out_estimacion &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_Bench_&quot;,mod,&quot;.rds&quot;) estimaciones &lt;- readRDS(infile) 5.2.2 Conteos agregados por dam y dam2 Este código carga los datos del censo de población y vivienda de Chile del año 2017, los cuales se encuentran en el archivo censo_mrp.rds. Luego, se filtran las observaciones de la población mayor a 15 año utilizando la función filter(). A continuación, se agrupan los datos por región (dam) y comuna (dam2) utilizando la función group_by(), y se calcula la suma del número de personas por comuna con la función sum(). Estos resultados se almacenan en una nueva columna llamada pp_dam2. Posteriormente, se utiliza la función add_tally() para sumar el peso de cada municipio y se guarda el resultado en una nueva columna llamada pp_dam. conteo_pp_dam &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/censo_mrp.rds&quot;) %&gt;% filter(edad &gt; 1) %&gt;% group_by(dam = depto, dam2 = mpio) %&gt;% summarise(pp_dam2 = sum(n)) %&gt;% add_tally(wt = pp_dam2, name = &quot;pp_dam&quot;) 5.2.3 Tranformando variables de la encuesta. Este código comienza definiendo las longitudes máximas de los campos _upm y _estrato en la tabla encuesta, y luego utiliza la función transmute() del paquete dplyr para crear una nueva tabla encuesta que contiene las columnas dam, nombre_dam, upm, estrato, fep y empleo. Para la columna dam, se utiliza la variable dam_ee para asignar un valor alfanumérico de dos dígitos para cada región y dominio (comuna). La función as_factor() convierte la variable a factor, con los valores y etiquetas correspondientes. La función str_pad() es utilizada para agregar ceros a la izquierda a la cadena de caracteres si la longitud de la cadena es menor que width. Para las columnas upm y estrato, la función str_pad() es utilizada para agregar ceros a la izquierda a la cadena de caracteres si la longitud de la cadena es menor que width. Las columnas fep y empleo simplemente se asignan a la tabla encuesta desde las columnas correspondientes de la tabla original. length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string =dam, width = 2, pad = &quot;0&quot;), nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = condact3 ) 5.2.4 Creando el objeto diseño En este código, se establece la opción survey.lonely.psu como adjust, lo que indica al paquete survey cómo tratar unidades de muestreo solitarias. A continuación, se utiliza la función as_survey_design() para crear un objeto de diseño de encuesta que puede ser utilizado para realizar análisis con el paquete survey. Se especifica que la variable estrato se utiliza como estrato y que upm se utiliza como identificador de unidad primaria de muestreo. Además, se incluye la variable fep como peso de diseño de muestreo. Se utiliza la opción nest=T para especificar que se desea crear un diseño anidado, lo que significa que cada unidad primaria de muestreo puede tener varias unidades secundarias de muestreo. options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) 5.2.5 Estimado el indicador El código proporciona un indicador agregado para los tres categorias de la variable empleo en cada región. Primero, se agrupa diseno por región (dam) y se filtran solo los casos con empleo entre 1 y 3. Luego, se utilizan las funciones survey_ratio() del paquete survey para calcular la proporción de personas en cada categoría de empleo ( Ocupado, Desocupado e Inactivo) en cada región. Por último, se seleccionan las columnas de dam, Ocupado, Desocupado e Inactivo para crear un marco de datos que incluya el indicador agregado. indicador_agregado &lt;- diseno %&gt;% group_by_at(&quot;dam&quot;) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( Ocupado = survey_ratio(numerator = (empleo == 1), denominator = 1 ), Desocupado = survey_ratio(numerator =( empleo == 2),denominator = 1 ), Inactivo = survey_ratio(numerator = (empleo == 3), denominator = 1 ) ) %&gt;% select(dam,Ocupado,Desocupado, Inactivo) 5.2.6 Organizando las estimaciones directas agregadas. El código toma el data.frame indicador_agregado y lo convierte de ancho a largo usando la función gather() de la librería tidyr. El argumento key = \"agregado\" especifica el nombre de la nueva variable creada que contendrá las columnas originales. El argumento value = \"estimacion\" especifica el nombre de la nueva variable creada que contendrá los valores originales de las columnas. El argumento -dam indica que la columna dam no debe ser incluida en la nueva estructura de datos. Luego, se agrega una nueva columna llamada nombre, que combina la cadena dam_ con los valores de las columnas dam y agregado en una cadena única para identificar cada estimación de razón de empleo. Finalmente, la función setNames() establece los nombres de los elementos del vector de estimaciones de razón de empleo en base a los valores únicos de la columna nombre. temp &lt;- gather(indicador_agregado, key = &quot;agregado&quot;, value = &quot;estimacion&quot;, -dam) %&gt;% mutate(nombre = paste0(&quot;dam_&quot;, dam,&quot;_&quot;, agregado)) Razon_empleo &lt;- setNames(temp$estimacion, temp$nombre) "],["benchmarking.html", "5.3 Benchmarking", " 5.3 Benchmarking El código realiza una manipulación de datos para obtener las estimaciones del modelo de área ajustado. En primer lugar, se selecciona el primer y segundo dígito de la variable dam2 para obtener la identificación de la DAM. Luego se utiliza la función inner_join() para combinar las estimaciones obtenidas del modelo con el conteo de la población por DAM, y así calcular los pesos de las DAMs. Estos pesos se almacenan en la variable wi. Finalmente, se seleccionan las variables de interés dam, dam2, Ocupado_mod, Desocupado_mod e Inactivo_mod, y se almacenan en la variable estimaciones_mod. names_cov &lt;- &quot;dam&quot; estimaciones_mod &lt;- estimaciones %&gt;% transmute( dam = substr(dam2,1,2), dam2,Ocupado_mod,Desocupado_mod,Inactivo_mod) %&gt;% inner_join(conteo_pp_dam ) %&gt;% mutate(wi = pp_dam2/pp_dam) Los valores no suman 1 dado que se elimina la antartida. estimaciones_mod %&gt;% group_by(dam) %&gt;% summarise(wi = sum(wi)) 5.3.1 Seleccionado variables Este código utiliza la función dummy_cols() del paquete fastDummies para crear variables dummy a partir de la columna dam. La opción select_columns = names_cov indica que solo se aplicará la creación de variables dummy a la columna especificada en names_cov (en este caso, dam). La opción remove_selected_columns = FALSE indica que la columna original no será eliminada. El resultado final es que se agregan nuevas columnas al conjunto de datos, una por cada valor único en la columna dam, que indican si el valor está presente o no para cada fila. estimaciones_mod %&lt;&gt;% fastDummies::dummy_cols(select_columns = names_cov, remove_selected_columns = FALSE) 5.3.2 Creando las dummys En este código se está creando una matriz de variables dummy para cada categoría de la variable dam, que en este caso es la división administrativa en la que se divide la muestra. Luego, se están multiplicando estas variables dummy por las estimaciones obtenidas del modelo en cada categoría de empleo ( ocupado, desocupado e inactivo) para cada dominio en la muestra. El resultado es una matriz de diseño que incluye tanto las variables dummy como las proporciones de empleo estimada. Xdummy &lt;- estimaciones_mod %&gt;% select(matches(&quot;dam_&quot;)) %&gt;% mutate_at(vars(matches(&quot;_\\\\d&quot;)) , list(Ocupado = function(x) x*estimaciones_mod$Ocupado_mod, Desocupado = function(x) x*estimaciones_mod$Desocupado_mod, Inactivo = function(x) x*estimaciones_mod$Inactivo_mod)) %&gt;% select((matches(&quot;Ocupado|Desocupado|Inactivo&quot;))) ahora, se validan la concordancia de los nombre colnames(Xdummy) == names(Razon_empleo) data.frame(Modelo = colSums(Xdummy*estimaciones_mod$wi), Estimacion_encuesta = Razon_empleo) Separando los nombres por cada categoría del empleo names_ocupado &lt;- grep(pattern = &quot;_O&quot;, x = colnames(Xdummy),value = TRUE) names_descupados &lt;- grep(pattern = &quot;_D&quot;, x = colnames(Xdummy),value = TRUE) names_inactivo &lt;- grep(pattern = &quot;_I&quot;, x = colnames(Xdummy),value = TRUE) 5.3.3 Obtenideno los ponderadores El código siguiente realiza un ajuste de calibración para los datos de empleo utilizando la función calib() del paquete sampling. La función recibe como argumentos la matriz de variables dummy correspondientes a los dominios, la variable de peso muestral d, y la razón poblacional para la variable de interés ( Ocupado, Desocupados e Inactivo). Se utiliza el método de calibración lineal y se establece un máximo de iteraciones de 5000. Posteriormente, se verifica la calidad del ajuste utilizando la función checkcalibration() del mismo paquete, la cual recibe como argumentos la matriz de variables dummy, la variable de peso muestral y la razón poblacional, junto con los resultados del ajuste previo gk_ocupado. Finalmente, se utiliza la función summary() para imprimir un resumen de los resultados del ajuste de calibración, el cual incluye información sobre el número de iteraciones, la convergencia, y los valores de las constantes de calibración. Ahora, se ejecuta el proceso para cada una de las categorías por separado. Ocupado gk_ocupado &lt;- calib(Xs = Xdummy[,names_ocupado], d = estimaciones_mod$wi, total = Razon_empleo[names_ocupado], method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_ocupado], d =estimaciones_mod$wi, total = Razon_empleo[names_ocupado], g = gk_ocupado,) Desocupado gk_desocupado &lt;- calib(Xs = Xdummy[,names_descupados], d = estimaciones_mod$wi, total = Razon_empleo[names_descupados], method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_descupados], d =estimaciones_mod$wi, total = Razon_empleo[names_descupados], g = gk_desocupado,) Inactivo gk_Inactivo &lt;- calib(Xs = Xdummy[,names_inactivo], d = estimaciones_mod$wi, total = Razon_empleo[names_inactivo], method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_inactivo], d =estimaciones_mod$wi, total = Razon_empleo[names_inactivo], g = gk_Inactivo,) validando los \\(gk\\)’s de forma visual. par(mfrow = c(1,3)) hist(gk_ocupado) hist(gk_desocupado) hist(gk_Inactivo) 5.3.4 Creando las estimaciones Benchmark estimacionesBench &lt;- estimaciones_mod %&gt;% mutate(gk_ocupado, gk_desocupado, gk_Inactivo) %&gt;% transmute( dam, dam2, wi,gk_ocupado, gk_desocupado, gk_Inactivo, Ocupado_Bench = Ocupado_mod*gk_ocupado, Desocupado_Bench = Desocupado_mod*gk_desocupado, Inactivo_Bench = Inactivo_mod*gk_Inactivo ) #############################33 Comparando resultados del Benchmarking estimacionesBench %&gt;% group_by(dam) %&gt;% summarise(Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) %&gt;% inner_join(indicador_agregado) dam Ocupado_Bench Desocupado_Bench Inactivo_Bench Ocupado Desocupado Inactivo 01 0.5849 0.0487 0.3665 0.5849 0.0487 0.3665 02 0.5561 0.0556 0.3882 0.5561 0.0556 0.3882 03 0.5246 0.0532 0.4222 0.5246 0.0532 0.4222 04 0.4697 0.0640 0.4663 0.4697 0.0640 0.4663 05 0.5176 0.0562 0.4262 0.5176 0.0562 0.4262 06 0.5235 0.0411 0.4354 0.5235 0.0411 0.4354 07 0.5144 0.0387 0.4469 0.5144 0.0387 0.4469 08 0.4771 0.0601 0.4629 0.4771 0.0601 0.4629 09 0.4903 0.0501 0.4596 0.4903 0.0501 0.4596 10 0.5323 0.0411 0.4266 0.5323 0.0411 0.4266 11 0.6180 0.0326 0.3494 0.6180 0.0326 0.3494 12 0.5923 0.0376 0.3701 0.5923 0.0376 0.3701 13 0.6040 0.0528 0.3432 0.6040 0.0528 0.3432 14 0.5060 0.0479 0.4461 0.5060 0.0479 0.4461 15 0.5100 0.0676 0.4224 0.5100 0.0676 0.4224 16 0.5023 0.0437 0.4540 0.5023 0.0437 0.4540 estimaciones &lt;- inner_join(estimaciones,estimacionesBench) Ordenando la base con las estimaciones directas y predichas saveRDS(object = estimaciones, file = out_estimacion) rm(list = ls()) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["validación-visual-del-benchmark.html", "Capítulo 6 Validación visual del Benchmark ", " Capítulo 6 Validación visual del Benchmark "],["lectura-de-librerias.html", "6.1 Lectura de librerias", " 6.1 Lectura de librerias plotly: Esta librería permite la creación de gráficos interactivos en R. Es muy útil para visualizar datos en línea y crear gráficos dinámicos con herramientas como zoom, tooltips y animaciones. dplyr: Permite manipular y transformar datos de forma fácil y rápida. Tiene una sintaxis sencilla y clara para filtrar, seleccionar, agrupar y resumir datos. tidyr: Ayuda a transformar datos de un formato a otro. Es muy útil para trabajar con datos desordenados o de formato ancho. forcats: Esta librería ayuda en la manipulación de variables categóricas en R. Permite crear, manipular y transformar factores. survey: Es una librería que permite el análisis de datos de encuestas utilizando métodos estadísticos apropiados para muestras complejas. Permite diseñar muestras estratificadas, con conglomerados y ponderadas. srvyr: Es una extensión de la librería dplyr para análisis de datos de encuestas complejas. Facilita la manipulación y visualización de datos de encuestas complejas. haven: Es una librería para la importación y exportación de datos de otros programas estadísticos, como SPSS, SAS y Stata. stringr: Ayuda en la manipulación de cadenas de caracteres en R. Permite la extracción de patrones de cadenas de caracteres, la manipulación de cadenas y la limpieza de datos. patchwork: Es una librería para la creación de gráficos complejos en R. Permite la combinación de múltiples gráficos en uno solo, con la posibilidad de modificar el tamaño y la posición de cada uno. library(plotly) library(dplyr) library(tidyr) library(forcats) library(survey) library(srvyr) library(haven) library(stringr) library(patchwork) "],["lectura-de-encuesta..html", "6.2 Lectura de encuesta.", " 6.2 Lectura de encuesta. El código está leyendo un archivo RDS llamado encuesta_2017.Rds y almacenándolo en un objeto llamado encuesta. Luego está leyendo otro archivo RDS que tiene el nombre estimaciones_Bench_fit_multinomial_con_covariable.rds y almacenando el contenido en un objeto llamado estimaciones. Finalmente, está filtrando las filas en el objeto estimaciones donde la columna dam es NA. encuesta &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/encuesta_2017.Rds&quot;) mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_Bench_&quot;,mod,&quot;.rds&quot;) estimaciones &lt;- readRDS(infile) "],["estimación-agregada.html", "6.3 Estimación agregada", " 6.3 Estimación agregada Esta parte de código toma el objeto estimaciones y lo resume por el campo dam. Para cada comuna, se calcula la suma ponderada de las variables Ocupado_mod, Desocupado_mod e Inactivo_mod (estimaciones del modelo) y de las variables Ocupado_Bench, Desocupado_Bench e Inactivo_Bench (estimaciones de la encuesta benchmark). Esto resulta en una tabla con seis columnas: dam, Ocupado_mod, Desocupado_mod, Inactivo_mod, Ocupado_Bench, Desocupado_Bench y Inactivo_Bench. estimaciones_agregada &lt;- estimaciones %&gt;% group_by(dam) %&gt;% summarise( Ocupado_mod = sum(wi*Ocupado_mod), Desocupado_mod = sum(wi*Desocupado_mod), Inactivo_mod = sum(wi*Inactivo_mod), Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) 6.3.1 Creación de objeto diseno Este código comienza definiendo las longitudes máximas de los campos _upm y _estrato en la tabla encuesta, y luego utiliza la función transmute() del paquete dplyr para crear una nueva tabla encuesta que contiene las columnas dam, nombre_dam, upm, estrato, fep y empleo. Para la columna dam, se utiliza la variable dam_ee para asignar un valor alfanumérico de dos dígitos para cada región y dominio (comuna). La función as_factor() convierte la variable a factor, con los valores y etiquetas correspondientes. La función str_pad() es utilizada para agregar ceros a la izquierda a la cadena de caracteres si la longitud de la cadena es menor que width. Para las columnas upm y estrato, la función str_pad() es utilizada para agregar ceros a la izquierda a la cadena de caracteres si la longitud de la cadena es menor que width. Las columnas fep y empleo simplemente se asignan a la tabla encuesta desde las columnas correspondientes de la tabla original. Después, se establece la opción survey.lonely.psu como adjust, lo que indica al paquete survey cómo tratar unidades de muestreo solitarias. A continuación, se utiliza la función as_survey_design() para crear un objeto de diseño de encuesta que puede ser utilizado para realizar análisis con el paquete survey. Se especifica que la variable estrato se utiliza como estrato y que upm se utiliza como identificador de unidad primaria de muestreo. Además, se incluye la variable fep como peso de diseño de muestreo. Se utiliza la opción nest=T para especificar que se desea crear un diseño anidado, lo que significa que cada unidad primaria de muestreo puede tener varias unidades secundarias de muestreo. length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string =dam, width = 2, pad = &quot;0&quot;), nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = condact3 ) options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) 6.3.2 Estimación del indicador El código proporciona un indicador agregado para los tres categorias de la variable empleo en cada región. Primero, se agrupa diseno por región (dam) y se filtran solo los casos con empleo entre 1 y 3. Luego, se utilizan las funciones survey_ratio() del paquete survey para calcular la proporción de personas en cada categoría de empleo ( Ocupado, Desocupado e Inactivo) en cada región. Por último, se seleccionan las columnas de dam, Ocupado, Desocupado e Inactivo para crear un marco de datos que incluya el indicador agregado. indicador_agregado &lt;- diseno %&gt;% group_by_at(&quot;dam&quot;) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( nd = unweighted(n()), Ocupado = survey_ratio(numerator = (empleo == 1), denominator = 1,vartype = c(&quot;ci&quot;), level = 0.95 ), Desocupado = survey_ratio(numerator =( empleo == 2),denominator = 1, vartype = c(&quot;ci&quot;), level = 0.95 ), Inactivo = survey_ratio(numerator = (empleo == 3), denominator = 1, vartype = c(&quot;ci&quot;), level = 0.95 ) ) data_plot &lt;- left_join(estimaciones_agregada, indicador_agregado) "],["gráfica-de-validación.html", "6.4 Gráfica de validación", " 6.4 Gráfica de validación La gráfica de validación compara las estimaciones directas, las del modelo y las ajustadas por benchmarking. En este código se genera un gráfico utilizando la librería ggplot2 de R. Primero, se seleccionan las variables correspondientes a las estimaciones del modelo para la categoría de empleo correspondiente ( Ocupado, Desocupado e Inactivo), se transforman los datos a formato largo con la función gather() y se asignan etiquetas para las distintas estimaciones. Luego, se crea un data.frame con los límites de los intervalos de confianza para las estimaciones obtenidas directamente de la encuesta. Finalmente, se utiliza la función ggplot() para graficar los datos, agregando una capa para mostrar los intervalos de confianza y otra capa para mostrar los valores de las estimaciones. Ocupado temp_ocupado &lt;- data_plot %&gt;% select(dam,nd, starts_with(&quot;Ocupado&quot;)) temp_ocupado_1 &lt;- temp_ocupado %&gt;% select(-Ocupado_low, -Ocupado_upp) %&gt;% gather(key = &quot;Estimacion&quot;,value = &quot;value&quot;, -nd,-dam) %&gt;% mutate(Estimacion = case_when(Estimacion == &quot;Ocupado_mod&quot; ~ &quot;Modelo de área&quot;, Estimacion == &quot;Ocupado_Bench&quot; ~ &quot;Modelo de área (bench)&quot;, Estimacion == &quot;Ocupado&quot;~ &quot;Directo&quot;)) lims_IC_ocupado &lt;- temp_ocupado %&gt;% select(dam,nd,value = Ocupado,Ocupado_low, Ocupado_upp) %&gt;% mutate(Estimacion = &quot;Directo&quot;) p_ocupado &lt;- ggplot(temp_ocupado_1, aes( x = fct_reorder2(dam, dam, nd), y = value, shape = Estimacion, color = Estimacion )) + geom_errorbar( data = lims_IC_ocupado, aes(ymin = Ocupado_low , ymax = Ocupado_upp, x = dam), width = 0.2, linewidth = 1 ) + geom_jitter(size = 3)+ labs(x = &quot;Dam&quot;, title = &quot;Ocupado&quot;) Desocupado temp_Desocupado &lt;- data_plot %&gt;% select(dam,nd, starts_with(&quot;Desocupado&quot;)) temp_Desocupado_1 &lt;- temp_Desocupado %&gt;% select(-Desocupado_low, -Desocupado_upp) %&gt;% gather(key = &quot;Estimacion&quot;,value = &quot;value&quot;, -nd,-dam) %&gt;% mutate(Estimacion = case_when(Estimacion == &quot;Desocupado_mod&quot; ~ &quot;Modelo de área&quot;, Estimacion == &quot;Desocupado_Bench&quot; ~ &quot;Modelo de área (bench)&quot;, Estimacion == &quot;Desocupado&quot;~ &quot;Directo&quot;)) lims_IC_Desocupado &lt;- temp_Desocupado %&gt;% select(dam,nd,value = Desocupado,Desocupado_low, Desocupado_upp) %&gt;% mutate(Estimacion = &quot;Directo&quot;) p_Desocupado &lt;- ggplot(temp_Desocupado_1, aes( x = fct_reorder2(dam, dam, nd), y = value, shape = Estimacion, color = Estimacion )) + geom_errorbar( data = lims_IC_Desocupado, aes(ymin = Desocupado_low , ymax = Desocupado_upp, x = dam), width = 0.2, linewidth = 1 ) + geom_jitter(size = 3)+ labs(x = &quot;Dam&quot;, title = &quot;Desocupado&quot;) Inactivo temp_Inactivo &lt;- data_plot %&gt;% select(dam,nd, starts_with(&quot;Inactivo&quot;)) temp_Inactivo_1 &lt;- temp_Inactivo %&gt;% select(-Inactivo_low, -Inactivo_upp) %&gt;% gather(key = &quot;Estimacion&quot;,value = &quot;value&quot;, -nd,-dam) %&gt;% mutate(Estimacion = case_when(Estimacion == &quot;Inactivo_mod&quot; ~ &quot;Modelo de área&quot;, Estimacion == &quot;Inactivo_Bench&quot; ~ &quot;Modelo de área (bench)&quot;, Estimacion == &quot;Inactivo&quot;~ &quot;Directo&quot;)) lims_IC_Inactivo &lt;- temp_Inactivo %&gt;% select(dam,nd,value = Inactivo,Inactivo_low, Inactivo_upp) %&gt;% mutate(Estimacion = &quot;Directo&quot;) p_Inactivo &lt;- ggplot(temp_Inactivo_1, aes( x = fct_reorder2(dam, dam, nd), y = value, shape = Estimacion, color = Estimacion )) + geom_errorbar( data = lims_IC_Inactivo, aes(ymin = Inactivo_low , ymax = Inactivo_upp, x = dam), width = 0.2, linewidth = 1 ) + geom_jitter(size = 3)+ labs(x = &quot;Dam&quot;, title = &quot;Inactivo&quot;) p_ocupado/p_Desocupado/p_Inactivo rm(list = ls()) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["mapas-de-resultados.html", "Capítulo 7 Mapas de resultados ", " Capítulo 7 Mapas de resultados "],["lectura-de-librerías-4.html", "7.1 Lectura de librerías", " 7.1 Lectura de librerías tidyverse: colección de paquetes de R diseñados para ciencia de datos. Incluye, entre otros, ggplot2, dplyr, tidyr. magrittr: paquete que ofrece una sintaxis para encadenar operaciones en R (%&gt;%). patchwork: paquete para crear visualizaciones complejas combinando múltiples gráficos en una sola trama. sp: paquete para trabajar con datos espaciales (análisis espacial, geoprocesamiento, etc.). sf: paquete para trabajar con datos geoespaciales (formato Simple Features). tmap: paquete para crear mapas temáticos en R. RColorBrewer: paquete que proporciona paletas de colores útiles para visualizaciones. maptools: paquete para leer y manipular datos geoespaciales. DescTools: paquete con funciones útiles para estadística descriptiva. library(tidyverse) library(magrittr) library(patchwork) library(sp) library(sf) library(tmap) library(RColorBrewer) library(maptools) library(DescTools) "],["parametrizando-el-código-1.html", "7.2 Parametrizando el código", " 7.2 Parametrizando el código Este código lee los resultados del modelo fit_multinomial_con_covariable y almacena la ubicación de los archivos de salida para tres gráficos en formato PDF y una imagen en formato PNG. Además, almacena los resultados del modelo en un objeto llamado “estimaciones”. mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_Bench_&quot;,mod,&quot;.rds&quot;) outOcupado &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Ocupados_&quot;,mod,&quot;.pdf&quot;) outDesocupado &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Desocupados_&quot;,mod,&quot;.pdf&quot;) outInactivo &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Inactivo_&quot;,mod,&quot;.pdf&quot;) outMosaico &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Mosaico_&quot;,mod,&quot;.png&quot;) estimaciones &lt;- readRDS(infile) "],["lectura-de-shapefile.html", "7.3 Lectura de shapefile", " 7.3 Lectura de shapefile ## leer shape del pais ShapeSAE &lt;- read_sf(&quot;01 Modelo de area/CHL/2017/ShapeDeptoCHL/comunas.shp&quot;) ShapeSAE %&lt;&gt;% mutate(dam2 = str_pad( string = cod_comuna, width = 5, pad = &quot;0&quot; ), dam = str_pad( string = codregion, width = 2, pad = &quot;0&quot; ) ) %&gt;% filter(dam != &quot;00&quot;, !dam2 %in% c(&quot;05201&quot;, &quot;13603&quot;)) "],["definición-del-mapa-con-tmap.html", "7.4 Definición del mapa con tmap", " 7.4 Definición del mapa con tmap ######################################### P1_empleo &lt;- tm_shape(ShapeSAE %&gt;% inner_join(estimaciones)) brks_ocupado &lt;- seq(0.3,0.8,0.1) brks_desocupado &lt;- seq(0,0.2,0.05) brks_inactivo &lt;- seq(0.15,0.6, 0.09) 7.4.1 Creando mapa de ocupados Mapa_ocupado &lt;- P1_empleo + tm_fill(&quot;Ocupado_mod&quot;, breaks = brks_ocupado, title = &quot;Ocupado&quot;, palette = &quot;-Blues&quot;) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3 ) Guardando el mapa de ocupados tmap_save( Mapa_ocupado, outOcupado, width = 6920, height = 4080, asp = 0 ) 7.4.2 Creando mapa de desocupados Mapa_desocupado &lt;- P1_empleo + tm_fill( &quot;Desocupado_mod&quot;, breaks = brks_desocupado, title = &quot;Desocupado&quot;, palette = &quot;YlOrRd&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Guardando el mapa de desocupado tmap_save( Mapa_desocupado, outDesocupado, width = 6920, height = 4080, asp = 0 ) 7.4.3 Creando mapa de inactivo Mapa_Inactivo &lt;- P1_empleo + tm_fill( &quot;Inactivo_mod&quot;, title = &quot;Inactivo&quot;, breaks = brks_inactivo, palette = &quot;YlGn&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Guardando el mapa de inactivo tmap_save( Mapa_Inactivo, outInactivo, width = 6920, height = 4080, asp = 0 ) creando un mosaico. mosaico &lt;- tmap_arrange(Mapa_Inactivo, Mapa_ocupado,Mapa_desocupado,ncol = 3, nrow = 1 ) guardar mosaico tmap_save( mosaico, outMosaico, width = 8920, height = 4080, asp = 0 ) knitr::include_graphics(&quot;Rmd/CHL/Recursos/Mosaico_fit_multinomial_con_covariable.png&quot;) "],["país-colombia..html", "Capítulo 8 País: Colombia.", " Capítulo 8 País: Colombia. La Gran Encuesta Integrada de Hogares (GEIH) es una encuesta realizada por el Departamento Administrativo Nacional de Estadística (DANE) en Colombia. Esta encuesta tiene como objetivo principal recopilar información sobre la situación económica y social de los hogares colombianos, incluyendo aspectos relacionados con el empleo, la educación, la salud, la vivienda, la pobreza y la desigualdad. La GEIH se realiza de forma continua durante todo el año, y cuenta con una muestra representativa de hogares seleccionados de manera aleatoria en todo el territorio colombiano. La muestra está diseñada para representar la diversidad socioeconómica y geográfica del país, y se estratifica por regiones, zonas urbanas y rurales, y tamaño de la población. La encuesta se realiza a través de entrevistas personales en los hogares seleccionados, y se recopila información sobre las características de los miembros del hogar, su situación laboral, ingresos, educación, salud, entre otros aspectos. La GEIH es considerada una fuente confiable de información estadística sobre la situación socioeconómica del país, y se utiliza para la elaboración de políticas públicas y la toma de decisiones en diferentes áreas. "],["lectura-de-la-encuesta-y-estimaciones-directas.html", "8.1 Lectura de la encuesta y estimaciones directas", " 8.1 Lectura de la encuesta y estimaciones directas En la primera línea se carga la encuesta desde un archivo RDS y se guarda en un objeto llamado encuesta. La segunda línea utiliza la función transmute() de la librería dplyr para seleccionar las variables de interés en la encuesta y crear nuevas variables a partir de ellas. Luego, se utiliza la variable id_dominio para identificar el dominio de estudio. En conjunto, estos pasos son fundamentales para preparar los datos de la encuesta para su posterior estimación del parámetro. encuesta &lt;- readRDS(&#39;01 Modelo de area/COL/2018/Data/encuestaCOL18N1.rds&#39;) ## encuesta &lt;- encuesta %&gt;% transmute( dam = dam_ee, dam2, fep = `_fep`, upm = segmento, estrato = paste0(dam, haven::as_factor(area_ee,levels = &quot;values&quot;)), empleo = condact3 ) id_dominio &lt;- &quot;dam2&quot; El código presentado define el diseño muestral para el análisis de la encuesta “encuesta” en R. La primera línea establece una opción para el tratamiento de las PSU (unidades primarias de muestreo) solitarias, lo que indica que se deben aplicar ajustes en el cálculo de los errores estándar. La segunda línea utiliza la función “as_survey_design” de la librería “survey” para definir el diseño muestral. La función toma como argumentos la variable “encuesta” y los siguientes parámetros: strata: la variable que define las estratas de muestreo en la encuesta, en este caso la variable “estrato”. ids: la variable que identifica las PSU en la encuesta, en este caso la variable “upm”. weights: la variable que indica los pesos muestrales de cada observación, en este caso la variable “fep”. nest: un parámetro lógico que indica si los datos de la encuesta están anidados o no. En este caso, se establece en “TRUE” porque los datos están anidados por dominio. En conjunto, estos pasos permiten definir un diseño muestral que tenga en cuenta las características del muestreo y los pesos asignados a cada observación en la encuesta, lo que es necesario para obtener estimaciones precisas y representativas de los parámetros de interés. options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) El código presentado es una operación que se realiza en el diseño muestral definido en el código anterior, con el objetivo de obtener un indicador del empleo por dominio. La primera línea define un objeto llamado “indicador_dam”. En la segunda línea, se agrupa el diseño muestral según el dominio especificado en la variable “id_dominio”. La tercera línea filtra los datos para quedarse con los individuos que tienen empleo (empleo igual a 1), están desempleados (empleo igual a 2) o son inactivos (empleo igual a 3). A partir de la cuarta línea, se utilizan las funciones “summarise” y “survey_mean” para calcular las estadísticas descriptivas de interés. En particular, se calculan el número de personas ocupadas, desocupadas e inactivas en cada dominio, y la proporción de personas en cada una de estas categorías. La función “survey_mean” se utiliza para calcular la proporción de personas en cada una de estas categorías con sus respectivos errores estándar y efecto de diseño. indicador_dam &lt;- diseno %&gt;% group_by_at(id_dominio) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( n_ocupado = unweighted(sum(empleo == 1)), n_desocupado = unweighted(sum(empleo == 2)), n_inactivo = unweighted(sum(empleo == 3)), Ocupado = survey_mean(empleo == 1, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Desocupado = survey_mean(empleo == 2, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Inactivo = survey_mean(empleo == 3, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ) ) "],["selección-de-dominios.html", "8.2 Selección de dominios", " 8.2 Selección de dominios En la sección anterior, se llevó a cabo una estimación directa para cada categoría individualmente en cada municipio (dominio) presente en la muestra. Ahora, para evaluar la calidad de los resultados obtenidos, realizaremos un análisis descriptivo. Se emplean varias medidas de calidad, entre ellas, se cuenta el número de dominios que tienen dos o más unidades primarias de muestreo (UPM), así como el efecto de diseño mayor a 1 y las varianzas mayores a 0. Estas medidas nos permitirán determinar la fiabilidad de nuestros resultados y tomar decisiones informadas en función de ellos. Después de realizar las validaciones anteriores se establece como regla incluir en el estudio los dominios que posean Dos o más UPM por dominio. Contar con un resultado en el Deff indicador_dam &lt;- encuesta %&gt;% select(id_dominio, upm) %&gt;% distinct() %&gt;% group_by_at(id_dominio) %&gt;% tally(name = &quot;n_upm&quot;) %&gt;% inner_join(indicador_dam, by = id_dominio) indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2, !is.na(Desocupado_deff)) %&gt;% mutate(id_orden = 1:n()) # saveRDS(object = indicador_dam1, &quot;Rmd/COL/Recursos/base_modelo.Rds&quot;) dam2 n_upm n_ocupado n_desocupado n_inactivo Ocupado Ocupado_se Ocupado_var Ocupado_deff Desocupado Desocupado_se Desocupado_var Desocupado_deff Inactivo Inactivo_se Inactivo_var Inactivo_deff id_orden 05001 806 13447 1805 8453 0.5772 0.0039 0.0000 1.5169 0.0775 0.0022 0e+00 1.6507 0.3453 0.0038 0.0000 1.5436 1 05002 10 102 7 118 0.4618 0.0202 0.0004 0.3739 0.0293 0.0083 1e-04 0.5478 0.5089 0.0186 0.0003 0.3127 2 05031 7 89 8 69 0.5307 0.0405 0.0016 1.0904 0.0626 0.0308 9e-04 2.6768 0.4066 0.0373 0.0014 0.9557 3 05034 6 100 3 82 0.5666 0.0322 0.0010 0.7805 0.0204 0.0076 1e-04 0.5345 0.4130 0.0327 0.0011 0.8153 4 05045 13 196 33 175 0.4808 0.0368 0.0014 2.1892 0.0920 0.0188 4e-04 1.7104 0.4272 0.0322 0.0010 1.7154 5 05079 6 71 14 74 0.4434 0.0460 0.0021 1.3676 0.0882 0.0130 2e-04 0.3359 0.4683 0.0521 0.0027 1.7387 6 05088 129 2169 321 1406 0.5647 0.0082 0.0001 1.0658 0.0827 0.0047 0e+00 1.1399 0.3526 0.0079 0.0001 1.0680 7 05093 6 81 1 55 0.5998 0.0415 0.0017 0.9791 0.0091 0.0088 1e-04 1.1823 0.3911 0.0455 0.0021 1.1878 8 05120 6 66 6 76 0.4384 0.0249 0.0006 0.3721 0.0300 0.0115 1e-04 0.6732 0.5316 0.0285 0.0008 0.4811 9 05129 17 273 22 201 0.5574 0.0145 0.0002 0.4255 0.0439 0.0090 1e-04 0.9649 0.3987 0.0191 0.0004 0.7575 10 "],["preparando-insumos-para-stan.html", "8.3 Preparando insumos para STAN", " 8.3 Preparando insumos para STAN Lectura y adecuación de covariables statelevel_predictors_df &lt;- readRDS(&#39;01 Modelo de area/COL/2018/Data/statelevel_predictors_df_dam2.rds&#39;) ## Estandarizando las variables para controlar el efecto de la escala. statelevel_predictors_df %&lt;&gt;% mutate_at(vars(&quot;luces_nocturnas&quot;, &quot;cubrimiento_cultivo&quot;, &quot;cubrimiento_urbano&quot;, &quot;modificacion_humana&quot;, &quot;accesibilidad_hospitales&quot;, &quot;accesibilidad_hosp_caminado&quot;), function(x)as.numeric(scale(x))) Seleccionar las variables del modelo y crear matriz de covariables. names_cov &lt;- c( &quot;dam2&quot;, &quot;tasa_desocupacion&quot;, &quot;hacinamiento&quot;, &quot;piso_tierra&quot;, &quot;luces_nocturnas&quot;, &quot;cubrimiento_cultivo&quot;, &quot;modificacion_humana&quot; ) X_pred &lt;- anti_join(statelevel_predictors_df %&gt;% select(all_of(names_cov)), indicador_dam1 %&gt;% select(dam2)) En el bloque de código se identifican que dominios serán los predichos. X_pred %&gt;% select(dam2) %&gt;% saveRDS(file = &quot;01 Modelo de area/COL/2018/Data/dam_pred.rds&quot;) Creando la matriz de covariables para los dominios no observados (X_pred) y los observados (X_obs) ## Obteniendo la matrix X_pred %&lt;&gt;% data.frame() %&gt;% select(-dam2) %&gt;% as.matrix() ## Identificando los dominios para realizar estimación del modelo X_obs &lt;- inner_join(indicador_dam1 %&gt;% select(dam2, id_orden), statelevel_predictors_df %&gt;% select(all_of(names_cov))) %&gt;% arrange(id_orden) %&gt;% data.frame() %&gt;% select(-dam2, -id_orden) %&gt;% as.matrix() Calculando el n_efectivo y el \\(\\tilde{y}\\) D &lt;- nrow(indicador_dam1) P &lt;- 3 # Ocupado, desocupado, inactivo. Y_tilde &lt;- matrix(NA, D, P) n_tilde &lt;- matrix(NA, D, P) # n efectivos ocupado n_tilde[,1] &lt;- (indicador_dam1$Ocupado*(1 - indicador_dam1$Ocupado))/indicador_dam1$Ocupado_var Y_tilde[,1] &lt;- n_tilde[,1]* indicador_dam1$Ocupado # n efectivos desocupado n_tilde[,2] &lt;- (indicador_dam1$Desocupado*(1 - indicador_dam1$Desocupado))/indicador_dam1$Desocupado_var Y_tilde[,2] &lt;- n_tilde[,2]* indicador_dam1$Desocupado # n efectivos Inactivo n_tilde[,3] &lt;- (indicador_dam1$Inactivo*(1 - indicador_dam1$Inactivo))/indicador_dam1$Inactivo_var Y_tilde[,3] &lt;- n_tilde[,3]* indicador_dam1$Inactivo Compilando el modelo X1_obs &lt;- cbind(matrix(1,nrow = D,ncol = 1),X_obs) K = ncol(X1_obs) D1 &lt;- nrow(X_pred) X1_pred &lt;- cbind(matrix(1,nrow = D1,ncol = 1),X_pred) sample_data &lt;- list(D = D, P = P, K = K, hat_y = Y_tilde, X_obs = X1_obs, X_pred = X1_pred, D1 = D1) library(rstan) fit_mcmc2 &lt;- stan( file = &quot;01 Modelo de area/0funciones/01 Multinomial_simple_pred.stan&quot;, # Stan program data = sample_data, # named list of data verbose = TRUE, warmup = 1000, # number of warmup iterations per chain iter = 2000, # total number of iterations per chain cores = 4, # number of cores (could use one per chain) ) saveRDS(fit_mcmc2, &quot;01 Modelo de area/COL/2018/Data/fit_multinomial_cor.Rds&quot;) "],["validación-del-modelo.html", "8.4 Validación del modelo", " 8.4 Validación del modelo La validación de un modelo es esencial para evaluar su capacidad para predecir de manera precisa y confiable los resultados futuros. En el caso de un modelo de área con respuesta multinomial, la validación se enfoca en medir la precisión del modelo para predecir las diferentes categorías de respuesta. El objetivo principal de la validación es determinar si el modelo es capaz de generalizar bien a datos no vistos y proporcionar predicciones precisas. Esto implica comparar las predicciones del modelo con los datos observados y utilizar métricas de evaluación para medir el rendimiento del modelo. La validación del modelo es esencial para garantizar la calidad de las predicciones y la confiabilidad del modelo para su uso en aplicaciones futuras. library(posterior) infile &lt;- paste0(&quot;01 Modelo de area/COL/2018/Data/fit_multinomial_cor.Rds&quot;) fit &lt;- readRDS(infile) theta_dir &lt;- indicador_dam1 %&gt;% transmute(dam2, n = n_desocupado + n_ocupado + n_inactivo, Ocupado, Desocupado, Inactivo) color_scheme_set(&quot;brightblue&quot;) theme_set(theme_bw(base_size = 15)) y_pred_B &lt;- as.array(fit, pars = &quot;theta&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = colnames(y_pred_B),value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = colnames(y_pred_B),value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = colnames(y_pred_B),value = TRUE) y_pred1 &lt;- y_pred_B[rowsrandom,theta_1 ] y_pred2 &lt;- y_pred_B[rowsrandom,theta_2 ] y_pred3 &lt;- y_pred_B[rowsrandom,theta_3 ] ppc_dens_overlay(y = as.numeric(theta_dir$Ocupado), y_pred1)/ ppc_dens_overlay(y = as.numeric(theta_dir$Desocupado), y_pred2)/ ppc_dens_overlay(y = as.numeric(theta_dir$Inactivo), y_pred3) La matriz de correlación de los efectos aleatorios. omega &lt;- summary(fit,&quot;Omega&quot;)$summary tba(omega) mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat Omega[1,1] 1.0000 NaN 0.0000 1.0000 1.0000 1.0000 1.0000 1.0000 NaN NaN Omega[1,2] 0.3113 0.0035 0.0632 0.1833 0.2703 0.3119 0.3553 0.4289 328.6787 1.0138 Omega[2,1] 0.3113 0.0035 0.0632 0.1833 0.2703 0.3119 0.3553 0.4289 328.6787 1.0138 Omega[2,2] 1.0000 0.0000 0.0000 1.0000 1.0000 1.0000 1.0000 1.0000 3935.2880 0.9990 8.4.1 Estimación de los parámetros. El código crea dos matrices, theta_obs_ordenado y theta_pred_ordenado, que contienen las estimaciones medias de los parámetros del modelo de respuesta multinomial con covariables para los datos de observación y predicción, respectivamente. La función matrix() se utiliza para dar formato a los datos con una matriz nrow x ncol, y se asignan nombres de columna apropiados a la matriz resultante utilizando colnames(). Luego se convierten las matrices en marcos de datos (as.data.frame()) y se unen mediante full_join() para crear una única tabla que contenga todas las estimaciones de los parámetros para los datos de observación y predicción, junto con la información del indicador de área (theta_dir). El resultado final es un marco de datos llamado estimaciones_obs. dam_pred &lt;- readRDS(&quot;01 Modelo de area/COL/2018/Data/dam_pred.rds&quot;) P &lt;- 3 D &lt;- nrow(indicador_dam1) D1 &lt;- nrow(dam_pred) ## Estimación del modelo. theta_obs &lt;- summary(fit, pars = &quot;theta&quot;)$summary[, &quot;mean&quot;] theta_pred &lt;- summary(fit, pars = &quot;theta_pred&quot;)$summary[, &quot;mean&quot;] ## Ordenando la matrix de theta theta_obs_ordenado &lt;- matrix(theta_obs, nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_obs_ordenado%&lt;&gt;% as.data.frame() theta_obs_ordenado &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado) theta_pred_ordenado &lt;- matrix(theta_pred, nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_pred_ordenado%&lt;&gt;% as.data.frame() theta_pred_ordenado &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado) 8.4.1.1 Estimación del desviación estárdar y el coeficiente de valiación Este bloque de código corresponde al cálculo de las desviaciones estándar (sd) y coeficientes de variación (cv) de los parámetros theta para los datos observados y predichos. En primer lugar, se utiliza la función summary() del paquete rstan para extraer los valores de sd de los parámetros theta observados y predichos, respectivamente, a partir del modelo (fit) que contiene la información de la estimación de los parámetros de la distribución Bayesiana. Luego, se organizan los valores de sd en una matriz ordenada por dam2 y se les asignan los nombres correspondientes. Con esta matriz, se calcula otra matriz que contiene los coeficientes de variación para los parámetros theta observados (theta_obs_ordenado_cv). De manera similar, se construyen matrices ordenadas por dam2 para los valores de sd y cv de los parámetros theta predichos (theta_pred_ordenado_sd y theta_pred_ordenado_cv, respectivamente). theta_obs_sd &lt;- summary(fit, pars = &quot;theta&quot;)$summary[, &quot;sd&quot;] theta_pred_sd &lt;- summary(fit, pars = &quot;theta_pred&quot;)$summary[, &quot;sd&quot;] theta_obs_ordenado_sd &lt;- matrix(theta_obs_sd, nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_obs_ordenado_sd%&lt;&gt;% as.data.frame() theta_obs_ordenado_sd &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_sd) theta_obs_ordenado_cv &lt;- theta_obs_ordenado_sd[,-1]/theta_obs_ordenado[,-1] colnames(theta_obs_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_obs_ordenado_cv &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_cv) theta_pred_ordenado_sd &lt;- matrix(theta_pred_sd, nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_pred_ordenado_sd%&lt;&gt;% as.data.frame() theta_pred_ordenado_sd &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_sd) theta_pred_ordenado_cv &lt;- theta_pred_ordenado_sd[,-1]/theta_pred_ordenado[,-1] colnames(theta_pred_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_pred_ordenado_cv &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_cv) El último paso es realizar la consolidación de la bases obtenidas para la estimación puntual, desviación estándar y coeficiente de variación. theta_obs_ordenado &lt;- full_join(theta_obs_ordenado,theta_obs_ordenado_sd) %&gt;% full_join(theta_obs_ordenado_cv) theta_pred_ordenado &lt;- full_join(theta_pred_ordenado,theta_pred_ordenado_sd) %&gt;% full_join(theta_pred_ordenado_cv) estimaciones &lt;- full_join(indicador_dam1, bind_rows(theta_obs_ordenado, theta_pred_ordenado)) saveRDS(object = estimaciones, file = &quot;Rmd/COL/Recursos/estimaciones.rds&quot;) tba(head(estimaciones,10)) dam2 n_upm n_ocupado n_desocupado n_inactivo Ocupado Ocupado_se Ocupado_var Ocupado_deff Desocupado Desocupado_se Desocupado_var Desocupado_deff Inactivo Inactivo_se Inactivo_var Inactivo_deff id_orden Ocupado_mod Desocupado_mod Inactivo_mod Ocupado_mod_sd Desocupado_mod_sd Inactivo_mod_sd Ocupado_mod_cv Desocupado_mod_cv Inactivo_mod_cv 05001 806 13447 1805 8453 0.5772 0.0039 0.0000 1.5169 0.0775 0.0022 0e+00 1.6507 0.3453 0.0038 0.0000 1.5436 1 0.5773 0.0775 0.3452 0.0041 0.0021 0.0039 0.0070 0.0273 0.0112 05002 10 102 7 118 0.4618 0.0202 0.0004 0.3739 0.0293 0.0083 1e-04 0.5478 0.5089 0.0186 0.0003 0.3127 2 0.4677 0.0320 0.5003 0.0195 0.0065 0.0195 0.0417 0.2031 0.0389 05031 7 89 8 69 0.5307 0.0405 0.0016 1.0904 0.0626 0.0308 9e-04 2.6768 0.4066 0.0373 0.0014 0.9557 3 0.5368 0.0581 0.4050 0.0344 0.0152 0.0336 0.0641 0.2611 0.0830 05034 6 100 3 82 0.5666 0.0322 0.0010 0.7805 0.0204 0.0076 1e-04 0.5345 0.4130 0.0327 0.0011 0.8153 4 0.5628 0.0316 0.4056 0.0296 0.0092 0.0295 0.0526 0.2904 0.0728 05045 13 196 33 175 0.4808 0.0368 0.0014 2.1892 0.0920 0.0188 4e-04 1.7104 0.4272 0.0322 0.0010 1.7154 5 0.4971 0.0782 0.4247 0.0313 0.0165 0.0308 0.0629 0.2109 0.0725 05079 6 71 14 74 0.4434 0.0460 0.0021 1.3676 0.0882 0.0130 2e-04 0.3359 0.4683 0.0521 0.0027 1.7387 6 0.4818 0.0782 0.4401 0.0367 0.0190 0.0359 0.0762 0.2432 0.0815 05088 129 2169 321 1406 0.5647 0.0082 0.0001 1.0658 0.0827 0.0047 0e+00 1.1399 0.3526 0.0079 0.0001 1.0680 7 0.5650 0.0824 0.3525 0.0082 0.0045 0.0080 0.0145 0.0551 0.0226 05093 6 81 1 55 0.5998 0.0415 0.0017 0.9791 0.0091 0.0088 1e-04 1.1823 0.3911 0.0455 0.0021 1.1878 8 0.5817 0.0276 0.3907 0.0373 0.0098 0.0365 0.0641 0.3561 0.0935 05120 6 66 6 76 0.4384 0.0249 0.0006 0.3721 0.0300 0.0115 1e-04 0.6732 0.5316 0.0285 0.0008 0.4811 9 0.4545 0.0302 0.5153 0.0249 0.0079 0.0249 0.0549 0.2607 0.0483 05129 17 273 22 201 0.5574 0.0145 0.0002 0.4255 0.0439 0.0090 1e-04 0.9649 0.3987 0.0191 0.0004 0.7575 10 0.5588 0.0450 0.3962 0.0153 0.0063 0.0151 0.0273 0.1402 0.0380 "],["metodología-de-benchmarking.html", "8.5 Metodología de Benchmarking", " 8.5 Metodología de Benchmarking Conteos de personas agregados por dam2, personas mayores de 15 años de edad. conteo_pp_dam &lt;- readRDS(&quot;01 Modelo de area/COL/2018/Data/censo_dam2.rds&quot;) %&gt;% filter(edad &gt; 1) %&gt;% group_by(dam , dam2) %&gt;% summarise(pp_dam2 = sum(n),.groups = &quot;drop&quot;) %&gt;% mutate(pp_dam = sum(pp_dam2)) Estimación del parámetro theta al nivel que la encuesta sea representativa. Razon_empleo &lt;- readRDS(&quot;Rmd/COL/Recursos/tablas.rds&quot;)$tbla2 tba(Razon_empleo) Ocupado Desocupado Inactivo 0.5779 0.0619 0.3602 Definir los pesos por dominios. names_cov &lt;- &quot;Nacional&quot; estimaciones_mod &lt;- estimaciones %&gt;% transmute( dam = substr(dam2,1,2), dam2,Ocupado_mod,Desocupado_mod,Inactivo_mod) %&gt;% inner_join(conteo_pp_dam ) %&gt;% mutate(wi = pp_dam2/pp_dam, Nacional = &quot;1&quot;) Crear variables dummys estimaciones_mod %&lt;&gt;% fastDummies::dummy_cols(select_columns = names_cov, remove_selected_columns = FALSE) Xdummy &lt;- estimaciones_mod %&gt;% select(matches(&quot;Nacional_&quot;)) %&gt;% mutate_at(vars(matches(&quot;_\\\\d&quot;)) , list(Ocupado = function(x) x*estimaciones_mod$Ocupado_mod, Desocupado = function(x) x*estimaciones_mod$Desocupado_mod, Inactivo = function(x) x*estimaciones_mod$Inactivo_mod)) %&gt;% select((matches(&quot;Ocupado|Desocupado|Inactivo&quot;))) Calcular el ponderador para cada nivel de la variable. Ocupado names_ocupado &lt;- grep(pattern = &quot;^O&quot;, x = colnames(Xdummy),value = TRUE) gk_ocupado &lt;- calib(Xs = Xdummy[,names_ocupado] %&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_ocupado] %&gt;% as.matrix(), method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_ocupado] %&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_ocupado] %&gt;% as.matrix(), g = gk_ocupado,) Desocupado names_descupados &lt;- grep(pattern = &quot;^D&quot;, x = colnames(Xdummy),value = TRUE) gk_desocupado &lt;- calib(Xs = Xdummy[,names_descupados]%&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_descupados]%&gt;% as.matrix(), method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_descupados]%&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_descupados]%&gt;% as.matrix(), g = gk_desocupado,) Inactivo names_inactivo &lt;- grep(pattern = &quot;^I&quot;, x = colnames(Xdummy),value = TRUE) gk_Inactivo &lt;- calib(Xs = Xdummy[,names_inactivo]%&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_inactivo]%&gt;% as.matrix(), method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_inactivo]%&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_inactivo]%&gt;% as.matrix(), g = gk_Inactivo,) Validar los resultados obtenidos. par(mfrow = c(1,3)) hist(gk_ocupado) hist(gk_desocupado) hist(gk_Inactivo) Estimaciones ajustadas por el ponderador estimacionesBench &lt;- estimaciones_mod %&gt;% mutate(gk_ocupado, gk_desocupado, gk_Inactivo) %&gt;% transmute( dam, dam2, wi,gk_ocupado, gk_desocupado, gk_Inactivo, Ocupado_Bench = Ocupado_mod*gk_ocupado, Desocupado_Bench = Desocupado_mod*gk_desocupado, Inactivo_Bench = Inactivo_mod*gk_Inactivo ) Validación de resultados. estimacionesBench %&gt;% summarise(Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) %&gt;% tba() Razon_empleo %&gt;% tba() Ocupado_Bench Desocupado_Bench Inactivo_Bench 0.5779 0.0619 0.3602 Ocupado Desocupado Inactivo 0.5779 0.0619 0.3602 Guardar resultados estimaciones &lt;- inner_join(estimaciones,estimacionesBench) saveRDS(object = estimaciones, file = &quot;Rmd/COL/Recursos/estimaciones_Bench.rds&quot;) "],["mapas-del-mercado-de-trabajo..html", "8.6 Mapas del mercado de trabajo.", " 8.6 Mapas del mercado de trabajo. library(sp) library(sf) library(tmap) ShapeSAE &lt;- read_sf(&quot;01 Modelo de area/COL/2018/ShapeDeptoCOL/COL_dam2.shp&quot;) P1_empleo &lt;- tm_shape(ShapeSAE %&gt;% inner_join(estimaciones)) brks_ocupado &lt;- seq(0.2,0.8,0.1) brks_desocupado &lt;- seq(0,0.2,0.05) brks_inactivo &lt;- seq(0.17,0.62, 0.09) Ocupado Mapa_ocupado &lt;- P1_empleo + tm_fill(&quot;Ocupado_Bench&quot;, breaks = brks_ocupado, title = &quot;Ocupado&quot;, palette = &quot;-Blues&quot;) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3 ) Mapa_ocupado Desocupado Mapa_desocupado &lt;- P1_empleo + tm_fill( &quot;Desocupado_Bench&quot;, breaks = brks_desocupado, title = &quot;Desocupado&quot;, palette = &quot;YlOrRd&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Mapa_desocupado Inactivo Mapa_Inactivo &lt;- P1_empleo + tm_fill( &quot;Inactivo_Bench&quot;, title = &quot;Inactivo&quot;, breaks = brks_inactivo, palette = &quot;YlGn&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) "],["país-perú..html", "Capítulo 9 País: Perú.", " Capítulo 9 País: Perú. La Encuesta Nacional de Hogares (ENAHO) es una encuesta anual que se lleva a cabo en Perú con el objetivo de obtener información sobre las características socioeconómicas de los hogares del país. La ENAHO es realizada por el Instituto Nacional de Estadística e Informática (INEI) y tiene una muestra representativa a nivel nacional y en áreas urbanas y rurales. Uno de los aspectos más importantes que se mide en la ENAHO es el empleo. A través de la encuesta se recopila información sobre la población en edad de trabajar, la población económicamente activa, la población ocupada y la población desocupada. La información obtenida en la ENAHO es utilizada para calcular la tasa de desempleo, la tasa de ocupación, la tasa de informalidad laboral, la tasa de subempleo, entre otros indicadores. Además del empleo, la ENAHO también recopila información sobre otros temas, como la educación, la salud, la vivienda, la alimentación y la pobreza. Los resultados de la encuesta son publicados en informes anuales que son utilizados por los gobiernos, empresas y organizaciones para tomar decisiones y diseñar políticas relacionadas con el empleo y la economía en general. La ENAHO es una herramienta importante para conocer la situación socioeconómica de los hogares peruanos y para la toma de decisiones de políticas públicas. La participación en la encuesta es voluntaria y la información proporcionada es confidencial. En resumen, la ENAHO es una fuente de información fundamental para entender el mercado laboral y la situación económica y social de los hogares en Perú. "],["lectura-de-la-encuesta-y-estimaciones-directas-1.html", "9.1 Lectura de la encuesta y estimaciones directas", " 9.1 Lectura de la encuesta y estimaciones directas En la primera línea se carga la encuesta desde un archivo RDS y se guarda en un objeto llamado encuesta. La segunda línea utiliza la función transmute() de la librería dplyr para seleccionar las variables de interés en la encuesta y crear nuevas variables a partir de ellas. Luego, se utiliza la variable id_dominio para identificar el dominio de estudio. En conjunto, estos pasos son fundamentales para preparar los datos de la encuesta para su posterior estimación del parámetro. encuesta &lt;- readRDS(&#39;01 Modelo de area/PER/2017/Data/encuesta_2017.Rds&#39;) length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string =dam, width = 2, pad = &quot;0&quot;), dam2 = dam2, nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), estrato = paste0(dam,estrato), fep = `_fep`, empleo = condact3 ) id_dominio &lt;- &quot;dam2&quot; El código presentado define el diseño muestral para el análisis de la encuesta “encuesta” en R. La primera línea establece una opción para el tratamiento de las PSU (unidades primarias de muestreo) solitarias, lo que indica que se deben aplicar ajustes en el cálculo de los errores estándar. La segunda línea utiliza la función “as_survey_design” de la librería “survey” para definir el diseño muestral. La función toma como argumentos la variable “encuesta” y los siguientes parámetros: strata: la variable que define las estratas de muestreo en la encuesta, en este caso la variable “estrato”. ids: la variable que identifica las PSU en la encuesta, en este caso la variable “upm”. weights: la variable que indica los pesos muestrales de cada observación, en este caso la variable “fep”. nest: un parámetro lógico que indica si los datos de la encuesta están anidados o no. En este caso, se establece en “TRUE” porque los datos están anidados por dominio. En conjunto, estos pasos permiten definir un diseño muestral que tenga en cuenta las características del muestreo y los pesos asignados a cada observación en la encuesta, lo que es necesario para obtener estimaciones precisas y representativas de los parámetros de interés. options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) El código presentado es una operación que se realiza en el diseño muestral definido en el código anterior, con el objetivo de obtener un indicador del empleo por dominio. La primera línea define un objeto llamado “indicador_dam”. En la segunda línea, se agrupa el diseño muestral según el dominio especificado en la variable “id_dominio”. La tercera línea filtra los datos para quedarse con los individuos que tienen empleo (empleo igual a 1), están desempleados (empleo igual a 2) o son inactivos (empleo igual a 3). A partir de la cuarta línea, se utilizan las funciones “summarise” y “survey_mean” para calcular las estadísticas descriptivas de interés. En particular, se calculan el número de personas ocupadas, desocupadas e inactivas en cada dominio, y la proporción de personas en cada una de estas categorías. La función “survey_mean” se utiliza para calcular la proporción de personas en cada una de estas categorías con sus respectivos errores estándar y efecto de diseño. indicador_dam &lt;- diseno %&gt;% group_by_at(id_dominio) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( n_ocupado = unweighted(sum(empleo == 1)), n_desocupado = unweighted(sum(empleo == 2)), n_inactivo = unweighted(sum(empleo == 3)), Ocupado = survey_mean(empleo == 1, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Desocupado = survey_mean(empleo == 2, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Inactivo = survey_mean(empleo == 3, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ) ) "],["selección-de-dominios-1.html", "9.2 Selección de dominios", " 9.2 Selección de dominios En la sección anterior, se llevó a cabo una estimación directa para cada categoría individualmente en cada municipio (dominio) presente en la muestra. Ahora, para evaluar la calidad de los resultados obtenidos, realizaremos un análisis descriptivo. Se emplean varias medidas de calidad, entre ellas, se cuenta el número de dominios que tienen dos o más unidades primarias de muestreo (UPM), así como el efecto de diseño mayor a 1 y las varianzas mayores a 0. Estas medidas nos permitirán determinar la fiabilidad de nuestros resultados y tomar decisiones informadas en función de ellos. Después de realizar las validaciones anteriores se establece como regla incluir en el estudio los dominios que posean Dos o más UPM por dominio. Contar con un resultado en el Deff Varianza estimada mayor a \\(10^{-7}\\) indicador_dam &lt;- encuesta %&gt;% select(id_dominio, upm) %&gt;% distinct() %&gt;% group_by_at(id_dominio) %&gt;% tally(name = &quot;n_upm&quot;) %&gt;% inner_join(indicador_dam, by = id_dominio) indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2, !is.na(Desocupado_deff), !is.na(Ocupado_deff), !is.na(Inactivo_deff), Desocupado_var &gt; 0.0000001, Ocupado_var &gt; 0.0000001, Inactivo_var &gt; 0.0000001) %&gt;% mutate(id_orden = 1:n()) # saveRDS(object = indicador_dam1, &quot;Rmd/PER/Recursos/base_modelo.Rds&quot;) dam2 n_upm n_ocupado n_desocupado n_inactivo Ocupado Ocupado_se Ocupado_var Ocupado_deff Desocupado Desocupado_se Desocupado_var Desocupado_deff Inactivo Inactivo_se Inactivo_var Inactivo_deff id_orden 010101 27 288 12 125 0.6764 0.0162 0.0003 0.5156 0.0278 0.0073 0.0001 0.8500 0.2958 0.0171 0.0003 0.6013 1 010201 11 127 2 56 0.6937 0.0296 0.0009 0.7620 0.0135 0.0131 0.0002 2.3718 0.2927 0.0372 0.0014 1.2349 2 010206 3 48 1 5 0.8633 0.0240 0.0006 0.2598 0.0255 0.0163 0.0003 0.5680 0.1112 0.0224 0.0005 0.2709 3 010307 3 37 2 12 0.7049 0.0359 0.0013 0.3112 0.0563 0.0330 0.0011 1.0334 0.2388 0.0645 0.0042 1.1492 4 010401 9 128 1 40 0.7427 0.0510 0.0026 2.3145 0.0083 0.0074 0.0001 1.1294 0.2490 0.0495 0.0024 2.2222 5 010403 5 90 1 22 0.8156 0.0338 0.0011 0.8589 0.0075 0.0071 0.0001 0.7671 0.1769 0.0342 0.0012 0.9096 6 010513 2 31 1 12 0.7045 0.0390 0.0015 0.3188 0.0227 0.0155 0.0002 0.4690 0.2727 0.0235 0.0006 0.1220 7 010701 23 256 8 67 0.7596 0.0271 0.0007 1.3373 0.0259 0.0101 0.0001 1.3487 0.2145 0.0272 0.0007 1.4655 8 010706 5 73 2 20 0.7396 0.0439 0.0019 0.9520 0.0353 0.0292 0.0009 2.3771 0.2251 0.0196 0.0004 0.2104 9 020101 14 168 6 80 0.6749 0.0277 0.0008 0.8879 0.0266 0.0089 0.0001 0.7734 0.2984 0.0289 0.0008 1.0127 10 "],["preparando-insumos-para-stan-1.html", "9.3 Preparando insumos para STAN", " 9.3 Preparando insumos para STAN Lectura y adecuación de covariables satelital_media &lt;- readRDS(&#39;01 Modelo de area/PER/2017/Data/satelital_media.rds&#39;) statelevel_censo &lt;- readRDS(&#39;01 Modelo de area/PER/2017/Data/statelevel_predictors_df_dam2.rds&#39;) %&gt;% mutate(dam2 = case_when(dam2 == &quot;120606&quot;~&quot;120699&quot;, TRUE ~ dam2)) statelevel_predictors_df &lt;- left_join(satelital_media,statelevel_censo) ## Estandarizando las variables para controlar el efecto de la escala. statelevel_predictors_df %&lt;&gt;% mutate_at(vars(&quot;luces_nocturnas&quot;, &quot;cubrimiento_cultivo&quot;, &quot;cubrimiento_urbano&quot;, &quot;modificacion_humana&quot;, &quot;accesibilidad_hospitales&quot;, &quot;accesibilidad_hosp_caminado&quot;), function(x)as.numeric(scale(x))) Seleccionar las variables del modelo y crear matriz de covariables. names_cov &lt;- c( &quot;dam2&quot;, &quot;luces_nocturnas&quot;, &quot;cubrimiento_cultivo&quot;, &quot;cubrimiento_urbano&quot;, &quot;modificacion_humana&quot;, &quot;tasa_desocupacion&quot;, &quot;discapacidad1&quot;, &quot;rezago_escolar&quot; ) X_pred &lt;- anti_join(statelevel_predictors_df %&gt;% select(all_of(names_cov)), indicador_dam1 %&gt;% select(dam2)) En el bloque de código se identifican que dominios serán los predichos. X_pred %&gt;% select(dam2) %&gt;% saveRDS(file = &quot;01 Modelo de area/PER/2017/Data/dam_pred.rds&quot;) Creando la matriz de covariables para los dominios no observados (X_pred) y los observados (X_obs) ## Obteniendo la matrix X_pred %&lt;&gt;% data.frame() %&gt;% select(-dam2) %&gt;% as.matrix() ## Identificando los dominios para realizar estimación del modelo X_obs &lt;- inner_join(indicador_dam1 %&gt;% select(dam2, id_orden), statelevel_predictors_df %&gt;% select(all_of(names_cov))) %&gt;% arrange(id_orden) %&gt;% data.frame() %&gt;% select(-dam2, -id_orden) %&gt;% as.matrix() Calculando el n_efectivo y el \\(\\tilde{y}\\) D &lt;- nrow(indicador_dam1) P &lt;- 3 # Ocupado, desocupado, inactivo. Y_tilde &lt;- matrix(NA, D, P) n_tilde &lt;- matrix(NA, D, P) # n efectivos ocupado n_tilde[,1] &lt;- (indicador_dam1$Ocupado*(1 - indicador_dam1$Ocupado))/indicador_dam1$Ocupado_var Y_tilde[,1] &lt;- n_tilde[,1]* indicador_dam1$Ocupado # n efectivos desocupado n_tilde[,2] &lt;- (indicador_dam1$Desocupado*(1 - indicador_dam1$Desocupado))/indicador_dam1$Desocupado_var Y_tilde[,2] &lt;- n_tilde[,2]* indicador_dam1$Desocupado # n efectivos Inactivo n_tilde[,3] &lt;- (indicador_dam1$Inactivo*(1 - indicador_dam1$Inactivo))/indicador_dam1$Inactivo_var Y_tilde[,3] &lt;- n_tilde[,3]* indicador_dam1$Inactivo Compilando el modelo X1_obs &lt;- cbind(matrix(1,nrow = D,ncol = 1),X_obs) K = ncol(X1_obs) D1 &lt;- nrow(X_pred) X1_pred &lt;- cbind(matrix(1,nrow = D1,ncol = 1),X_pred) sample_data &lt;- list(D = D, P = P, K = K, hat_y = Y_tilde, X_obs = X1_obs, X_pred = X1_pred, D1 = D1) library(rstan) fit_mcmc2 &lt;- stan( file = &quot;01 Modelo de area/0funciones/01 Multinomial_simple_pred.stan&quot;, # Stan program data = sample_data, # named list of data verbose = TRUE, warmup = 1000, # number of warmup iterations per chain iter = 2000, # total number of iterations per chain cores = 4, # number of cores (could use one per chain) ) saveRDS(fit_mcmc2, &quot;01 Modelo de area/PER/2017/Data/fit_rtanmultinomial_con_covariable_satelite.Rds&quot;) "],["validación-del-modelo-1.html", "9.4 Validación del modelo", " 9.4 Validación del modelo La validación de un modelo es esencial para evaluar su capacidad para predecir de manera precisa y confiable los resultados futuros. En el caso de un modelo de área con respuesta multinomial, la validación se enfoca en medir la precisión del modelo para predecir las diferentes categorías de respuesta. El objetivo principal de la validación es determinar si el modelo es capaz de generalizar bien a datos no vistos y proporcionar predicciones precisas. Esto implica comparar las predicciones del modelo con los datos observados y utilizar métricas de evaluación para medir el rendimiento del modelo. La validación del modelo es esencial para garantizar la calidad de las predicciones y la confiabilidad del modelo para su uso en aplicaciones futuras. library(posterior) infile &lt;- paste0(&quot;01 Modelo de area/PER/2017/Data/fit_rtanmultinomial_con_covariable_satelite.Rds&quot;) fit &lt;- readRDS(infile) theta_dir &lt;- indicador_dam1 %&gt;% transmute(dam2, n = n_desocupado + n_ocupado + n_inactivo, Ocupado, Desocupado, Inactivo) color_scheme_set(&quot;brightblue&quot;) theme_set(theme_bw(base_size = 15)) y_pred_B &lt;- as.array(fit, pars = &quot;theta&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = colnames(y_pred_B),value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = colnames(y_pred_B),value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = colnames(y_pred_B),value = TRUE) y_pred1 &lt;- y_pred_B[rowsrandom,theta_1 ] y_pred2 &lt;- y_pred_B[rowsrandom,theta_2 ] y_pred3 &lt;- y_pred_B[rowsrandom,theta_3 ] ppc_dens_overlay(y = as.numeric(theta_dir$Ocupado), y_pred1)/ ppc_dens_overlay(y = as.numeric(theta_dir$Desocupado), y_pred2)/ ppc_dens_overlay(y = as.numeric(theta_dir$Inactivo), y_pred3) La matriz de correlación de los efectos aleatorios. omega &lt;- summary(fit,&quot;Omega&quot;)$summary tba(omega) mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat Omega[1,1] 1.0000 NaN 0.0000 1.0000 1.0000 1.0000 1.0000 1.000 NaN NaN Omega[1,2] 0.2072 0.0024 0.0762 0.0594 0.1554 0.2077 0.2602 0.355 996.1386 1.0007 Omega[2,1] 0.2072 0.0024 0.0762 0.0594 0.1554 0.2077 0.2602 0.355 996.1386 1.0007 Omega[2,2] 1.0000 0.0000 0.0000 1.0000 1.0000 1.0000 1.0000 1.000 7672.2241 0.9995 9.4.1 Estimación de los parámetros. El código crea dos matrices, theta_obs_ordenado y theta_pred_ordenado, que contienen las estimaciones medias de los parámetros del modelo de respuesta multinomial con covariables para los datos de observación y predicción, respectivamente. La función matrix() se utiliza para dar formato a los datos con una matriz nrow x ncol, y se asignan nombres de columna apropiados a la matriz resultante utilizando colnames(). Luego se convierten las matrices en marcos de datos (as.data.frame()) y se unen mediante full_join() para crear una única tabla que contenga todas las estimaciones de los parámetros para los datos de observación y predicción, junto con la información del indicador de área (theta_dir). El resultado final es un marco de datos llamado estimaciones_obs. dam_pred &lt;- readRDS(&quot;01 Modelo de area/PER/2017/Data/dam_pred.rds&quot;) P &lt;- 3 D &lt;- nrow(indicador_dam1) D1 &lt;- nrow(dam_pred) ## Estimación del modelo. theta_obs &lt;- summary(fit, pars = &quot;theta&quot;)$summary[, &quot;mean&quot;] theta_pred &lt;- summary(fit, pars = &quot;theta_pred&quot;)$summary[, &quot;mean&quot;] ## Ordenando la matrix de theta theta_obs_ordenado &lt;- matrix(theta_obs, nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_obs_ordenado%&lt;&gt;% as.data.frame() theta_obs_ordenado &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado) theta_pred_ordenado &lt;- matrix(theta_pred, nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_pred_ordenado%&lt;&gt;% as.data.frame() theta_pred_ordenado &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado) 9.4.1.1 Estimación del desviación estárdar y el coeficiente de valiación Este bloque de código corresponde al cálculo de las desviaciones estándar (sd) y coeficientes de variación (cv) de los parámetros theta para los datos observados y predichos. En primer lugar, se utiliza la función summary() del paquete rstan para extraer los valores de sd de los parámetros theta observados y predichos, respectivamente, a partir del modelo (fit) que contiene la información de la estimación de los parámetros de la distribución Bayesiana. Luego, se organizan los valores de sd en una matriz ordenada por dam2 y se les asignan los nombres correspondientes. Con esta matriz, se calcula otra matriz que contiene los coeficientes de variación para los parámetros theta observados (theta_obs_ordenado_cv). De manera similar, se construyen matrices ordenadas por dam2 para los valores de sd y cv de los parámetros theta predichos (theta_pred_ordenado_sd y theta_pred_ordenado_cv, respectivamente). theta_obs_sd &lt;- summary(fit, pars = &quot;theta&quot;)$summary[, &quot;sd&quot;] theta_pred_sd &lt;- summary(fit, pars = &quot;theta_pred&quot;)$summary[, &quot;sd&quot;] theta_obs_ordenado_sd &lt;- matrix(theta_obs_sd, nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_obs_ordenado_sd%&lt;&gt;% as.data.frame() theta_obs_ordenado_sd &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_sd) theta_obs_ordenado_cv &lt;- theta_obs_ordenado_sd[,-1]/theta_obs_ordenado[,-1] colnames(theta_obs_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_obs_ordenado_cv &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_cv) theta_pred_ordenado_sd &lt;- matrix(theta_pred_sd, nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_pred_ordenado_sd%&lt;&gt;% as.data.frame() theta_pred_ordenado_sd &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_sd) theta_pred_ordenado_cv &lt;- theta_pred_ordenado_sd[,-1]/theta_pred_ordenado[,-1] colnames(theta_pred_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_pred_ordenado_cv &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_cv) El último paso es realizar la consolidación de la bases obtenidas para la estimación puntual, desviación estándar y coeficiente de variación. theta_obs_ordenado &lt;- full_join(theta_obs_ordenado,theta_obs_ordenado_sd) %&gt;% full_join(theta_obs_ordenado_cv) theta_pred_ordenado &lt;- full_join(theta_pred_ordenado,theta_pred_ordenado_sd) %&gt;% full_join(theta_pred_ordenado_cv) estimaciones &lt;- full_join(indicador_dam1, bind_rows(theta_obs_ordenado, theta_pred_ordenado)) saveRDS(object = estimaciones, file = &quot;Rmd/PER/Recursos/estimaciones.rds&quot;) tba(head(estimaciones,10)) dam2 n_upm n_ocupado n_desocupado n_inactivo Ocupado Ocupado_se Ocupado_var Ocupado_deff Desocupado Desocupado_se Desocupado_var Desocupado_deff Inactivo Inactivo_se Inactivo_var Inactivo_deff id_orden Ocupado_mod Desocupado_mod Inactivo_mod Ocupado_mod_sd Desocupado_mod_sd Inactivo_mod_sd Ocupado_mod_cv Desocupado_mod_cv Inactivo_mod_cv 010101 27 288 12 125 0.6764 0.0162 0.0003 0.5156 0.0278 0.0073 0.0001 0.8500 0.2958 0.0171 0.0003 0.6013 1 0.6753 0.0288 0.2959 0.0161 0.0053 0.0157 0.0238 0.1854 0.0532 010201 11 127 2 56 0.6937 0.0296 0.0009 0.7620 0.0135 0.0131 0.0002 2.3718 0.2927 0.0372 0.0014 1.2349 2 0.6919 0.0243 0.2838 0.0276 0.0073 0.0273 0.0398 0.3016 0.0960 010206 3 48 1 5 0.8633 0.0240 0.0006 0.2598 0.0255 0.0163 0.0003 0.5680 0.1112 0.0224 0.0005 0.2709 3 0.8246 0.0303 0.1451 0.0220 0.0087 0.0202 0.0267 0.2860 0.1392 010307 3 37 2 12 0.7049 0.0359 0.0013 0.3112 0.0563 0.0330 0.0011 1.0334 0.2388 0.0645 0.0042 1.1492 4 0.7050 0.0470 0.2479 0.0325 0.0135 0.0312 0.0462 0.2873 0.1257 010401 9 128 1 40 0.7427 0.0510 0.0026 2.3145 0.0083 0.0074 0.0001 1.1294 0.2490 0.0495 0.0024 2.2222 5 0.7261 0.0219 0.2520 0.0387 0.0082 0.0381 0.0533 0.3739 0.1510 010403 5 90 1 22 0.8156 0.0338 0.0011 0.8589 0.0075 0.0071 0.0001 0.7671 0.1769 0.0342 0.0012 0.9096 6 0.7785 0.0183 0.2031 0.0288 0.0066 0.0282 0.0370 0.3607 0.1386 010513 2 31 1 12 0.7045 0.0390 0.0015 0.3188 0.0227 0.0155 0.0002 0.4690 0.2727 0.0235 0.0006 0.1220 7 0.7021 0.0291 0.2688 0.0275 0.0087 0.0270 0.0391 0.2987 0.1005 010701 23 256 8 67 0.7596 0.0271 0.0007 1.3373 0.0259 0.0101 0.0001 1.3487 0.2145 0.0272 0.0007 1.4655 8 0.7491 0.0303 0.2206 0.0243 0.0081 0.0234 0.0325 0.2680 0.1061 010706 5 73 2 20 0.7396 0.0439 0.0019 0.9520 0.0353 0.0292 0.0009 2.3771 0.2251 0.0196 0.0004 0.2104 9 0.7369 0.0329 0.2301 0.0280 0.0094 0.0267 0.0381 0.2868 0.1162 020101 14 168 6 80 0.6749 0.0277 0.0008 0.8879 0.0266 0.0089 0.0001 0.7734 0.2984 0.0289 0.0008 1.0127 10 0.6711 0.0299 0.2990 0.0261 0.0079 0.0255 0.0389 0.2630 0.0854 "],["metodología-de-benchmarking-1.html", "9.5 Metodología de Benchmarking", " 9.5 Metodología de Benchmarking Conteos de personas agregados por dam2, personas mayores de 15 años de edad. conteo_pp_dam &lt;- readRDS(&quot;01 Modelo de area/PER/2017/Data/censo_dam2.rds&quot;) %&gt;% filter(edad &gt; 1) %&gt;% group_by(dam = depto, dam2 = mpio) %&gt;% summarise(pp_dam2 = sum(n)) %&gt;% add_tally(wt = pp_dam2, name = &quot;pp_dam&quot;) %&gt;% mutate(dam2 = case_when(dam2 == &quot;120606&quot;~&quot;120699&quot;, TRUE ~ dam2)) Estimación del parámetro theta al nivel que la encuesta sea representativa. Razon_empleo &lt;- readRDS(&quot;Rmd/PER/Recursos/Razon_empleo.rds&quot;) tba(data.frame(estimate_dir = Razon_empleo) %&gt;% head(10)) estimate_dir dam_01_Ocupado 0.7462 dam_02_Ocupado 0.7066 dam_03_Ocupado 0.7846 dam_04_Ocupado 0.6630 dam_05_Ocupado 0.7219 dam_06_Ocupado 0.7791 dam_07_Ocupado 0.6290 dam_08_Ocupado 0.7574 dam_09_Ocupado 0.8197 dam_10_Ocupado 0.7163 Definir los pesos por dominios. names_cov &lt;- &quot;dam&quot; estimaciones_mod &lt;- estimaciones %&gt;% transmute( dam = substr(dam2,1,2), dam2,Ocupado_mod,Desocupado_mod,Inactivo_mod) %&gt;% inner_join(conteo_pp_dam ) %&gt;% mutate(wi = pp_dam2/pp_dam) Crear variables dummys estimaciones_mod %&lt;&gt;% fastDummies::dummy_cols(select_columns = names_cov, remove_selected_columns = FALSE) Xdummy &lt;- estimaciones_mod %&gt;% select(matches(&quot;dam_&quot;)) %&gt;% mutate_at(vars(matches(&quot;_\\\\d&quot;)) , list(Ocupado = function(x) x*estimaciones_mod$Ocupado_mod, Desocupado = function(x) x*estimaciones_mod$Desocupado_mod, Inactivo = function(x) x*estimaciones_mod$Inactivo_mod)) %&gt;% select((matches(&quot;Ocupado|Desocupado|Inactivo&quot;))) Calcular el ponderador para cada nivel de la variable. Ocupado names_ocupado &lt;- grep(pattern = &quot;_O&quot;, x = colnames(Xdummy),value = TRUE) gk_ocupado &lt;- calib(Xs = Xdummy[,names_ocupado] %&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_ocupado] %&gt;% as.matrix(), method=&quot;logit&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_ocupado] %&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_ocupado] %&gt;% as.matrix(), g = gk_ocupado,) Desocupado names_descupados &lt;- grep(pattern = &quot;_D&quot;, x = colnames(Xdummy),value = TRUE) gk_desocupado &lt;- calib(Xs = Xdummy[,names_descupados]%&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_descupados]%&gt;% as.matrix(), method=&quot;logit&quot;,max_iter = 5000) checkcalibration(Xs = Xdummy[,names_descupados]%&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_descupados]%&gt;% as.matrix(), g = gk_desocupado,) Inactivo names_inactivo &lt;- grep(pattern = &quot;_I&quot;, x = colnames(Xdummy),value = TRUE) gk_Inactivo &lt;- calib(Xs = Xdummy[,names_inactivo]%&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_inactivo]%&gt;% as.matrix(), method=&quot;logit&quot;,max_iter = 5000) checkcalibration(Xs = Xdummy[,names_inactivo]%&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_inactivo]%&gt;% as.matrix(), g = gk_Inactivo,) Validar los resultados obtenidos. par(mfrow = c(1,3)) hist(gk_ocupado) hist(gk_desocupado) hist(gk_Inactivo) Estimaciones ajustadas por el ponderador estimacionesBench &lt;- estimaciones_mod %&gt;% mutate(gk_ocupado, gk_desocupado, gk_Inactivo) %&gt;% transmute( dam, dam2, wi,gk_ocupado, gk_desocupado, gk_Inactivo, Ocupado_Bench = Ocupado_mod*gk_ocupado, Desocupado_Bench = Desocupado_mod*gk_desocupado, Inactivo_Bench = Inactivo_mod*gk_Inactivo ) Validación de resultados. indicador_agregado &lt;- readRDS(&quot;Rmd/PER/Recursos/indicador_agregado.rds&quot;) estimacionesBench %&gt;% group_by(dam) %&gt;% summarise(Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) %&gt;% inner_join(indicador_agregado) %&gt;% tba() dam Ocupado_Bench Desocupado_Bench Inactivo_Bench Ocupado Desocupado Inactivo 01 0.7462 0.0114 0.2424 0.7462 0.0114 0.2424 02 0.7066 0.0197 0.2738 0.7066 0.0197 0.2738 03 0.7846 0.0126 0.2027 0.7846 0.0126 0.2027 04 0.6630 0.0294 0.3077 0.6630 0.0294 0.3077 05 0.7219 0.0201 0.2580 0.7219 0.0201 0.2580 06 0.7791 0.0126 0.2083 0.7791 0.0126 0.2083 07 0.6290 0.0434 0.3275 0.6290 0.0434 0.3275 08 0.7574 0.0212 0.2214 0.7574 0.0212 0.2214 09 0.8197 0.0171 0.1632 0.8197 0.0171 0.1632 10 0.7163 0.0225 0.2612 0.7163 0.0225 0.2612 11 0.6504 0.0177 0.3319 0.6504 0.0177 0.3319 12 0.7020 0.0136 0.2844 0.7020 0.0136 0.2844 13 0.6726 0.0203 0.3071 0.6726 0.0203 0.3071 14 0.6457 0.0221 0.3323 0.6457 0.0221 0.3323 15 0.6474 0.0428 0.3099 0.6474 0.0428 0.3099 16 0.6771 0.0154 0.3075 0.6771 0.0154 0.3075 17 0.7257 0.0145 0.2597 0.7257 0.0145 0.2597 18 0.6795 0.0308 0.2897 0.6795 0.0308 0.2897 19 0.7215 0.0294 0.2491 0.7215 0.0294 0.2491 20 0.6608 0.0175 0.3217 0.6608 0.0175 0.3217 21 0.7522 0.0202 0.2277 0.7522 0.0202 0.2277 22 0.7264 0.0179 0.2557 0.7264 0.0179 0.2557 23 0.6498 0.0280 0.3222 0.6498 0.0280 0.3222 24 0.6737 0.0314 0.2950 0.6737 0.0314 0.2950 25 0.7046 0.0199 0.2755 0.7046 0.0199 0.2755 Guardar resultados estimaciones &lt;- inner_join(estimaciones,estimacionesBench) saveRDS(object = estimaciones, file = &quot;Rmd/PER/Recursos/estimaciones_Bench.rds&quot;) "],["mapas-del-mercado-de-trabajo.-1.html", "9.6 Mapas del mercado de trabajo.", " 9.6 Mapas del mercado de trabajo. library(sp) library(sf) library(tmap) ShapeSAE &lt;- read_sf(&quot;01 Modelo de area/PER/2017/Shape/PER_dam2.shp&quot;) P1_empleo &lt;- tm_shape(ShapeSAE %&gt;% left_join(estimaciones)) brks_ocupado &lt;- seq(0.4,1,0.1) brks_desocupado &lt;- seq(0,0.1,0.02) brks_inactivo &lt;- seq(0.10,0.65, 0.09) Ocupado Mapa_ocupado &lt;- P1_empleo + tm_fill(&quot;Ocupado_Bench&quot;, breaks = brks_ocupado, title = &quot;Ocupado&quot;, palette = &quot;-Blues&quot;) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3 ) Mapa_ocupado Desocupado Mapa_desocupado &lt;- P1_empleo + tm_fill( &quot;Desocupado_Bench&quot;, breaks = brks_desocupado, title = &quot;Desocupado&quot;, palette = &quot;YlOrRd&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Mapa_desocupado Inactivo Mapa_Inactivo &lt;- P1_empleo + tm_fill( &quot;Inactivo_Bench&quot;, title = &quot;Inactivo&quot;, breaks = brks_inactivo, palette = &quot;YlGn&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) "],["país-méxico..html", "Capítulo 10 País: México.", " Capítulo 10 País: México. En México, la Encuesta Nacional de Ocupación y Empleo (ENOE) es la encuesta de hogares que se utiliza para medir el empleo y otras características laborales de la población. La ENOE es realizada por el Instituto Nacional de Estadística y Geografía (INEGI) de manera trimestral y tiene una muestra representativa a nivel nacional y en áreas urbanas y rurales. A través de la ENOE, se obtiene información sobre la población en edad de trabajar, la población económicamente activa, la población ocupada y la población desocupada, así como otros indicadores relacionados con el empleo, como la informalidad laboral, el subempleo y las condiciones laborales. Además del empleo, la ENOE también recopila información sobre otros temas, como la educación, la salud, la vivienda y la pobreza. Los resultados de la encuesta son publicados en informes trimestrales que son utilizados por los gobiernos, empresas y organizaciones para tomar decisiones y diseñar políticas relacionadas con el empleo y la economía en general. Es importante destacar que la ENOE es una fuente de información fundamental para entender la situación laboral en México y es utilizada por organismos nacionales e internacionales para comparar la situación laboral de diferentes países. La participación en la encuesta es voluntaria y la información proporcionada es confidencial. En resumen, la ENOE es una herramienta importante para conocer el mercado laboral y la situación económica y social de los hogares en México. "],["lectura-de-la-encuesta-y-estimaciones-directas-2.html", "10.1 Lectura de la encuesta y estimaciones directas", " 10.1 Lectura de la encuesta y estimaciones directas En la primera línea se carga la encuesta desde un archivo RDS y se guarda en un objeto llamado encuesta. La segunda línea utiliza la función transmute() de la librería dplyr para seleccionar las variables de interés en la encuesta y crear nuevas variables a partir de ellas. Luego, se utiliza la variable id_dominio para identificar el dominio de estudio. En conjunto, estos pasos son fundamentales para preparar los datos de la encuesta para su posterior estimación del parámetro. encuesta &lt;- readRDS(&#39;01 Modelo de area/MEX/2020/Data/encuesta_2020.Rds&#39;) length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string =dam, width = 2, pad = &quot;0&quot;), dam2 = dam2, nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = condact3 ) id_dominio &lt;- &quot;dam2&quot; El código presentado define el diseño muestral para el análisis de la encuesta “encuesta” en R. La primera línea establece una opción para el tratamiento de las PSU (unidades primarias de muestreo) solitarias, lo que indica que se deben aplicar ajustes en el cálculo de los errores estándar. La segunda línea utiliza la función “as_survey_design” de la librería “survey” para definir el diseño muestral. La función toma como argumentos la variable “encuesta” y los siguientes parámetros: strata: la variable que define las estratas de muestreo en la encuesta, en este caso la variable “estrato”. ids: la variable que identifica las PSU en la encuesta, en este caso la variable “upm”. weights: la variable que indica los pesos muestrales de cada observación, en este caso la variable “fep”. nest: un parámetro lógico que indica si los datos de la encuesta están anidados o no. En este caso, se establece en “TRUE” porque los datos están anidados por dominio. En conjunto, estos pasos permiten definir un diseño muestral que tenga en cuenta las características del muestreo y los pesos asignados a cada observación en la encuesta, lo que es necesario para obtener estimaciones precisas y representativas de los parámetros de interés. options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) El código presentado es una operación que se realiza en el diseño muestral definido en el código anterior, con el objetivo de obtener un indicador del empleo por dominio. La primera línea define un objeto llamado “indicador_dam”. En la segunda línea, se agrupa el diseño muestral según el dominio especificado en la variable “id_dominio”. La tercera línea filtra los datos para quedarse con los individuos que tienen empleo (empleo igual a 1), están desempleados (empleo igual a 2) o son inactivos (empleo igual a 3). A partir de la cuarta línea, se utilizan las funciones “summarise” y “survey_mean” para calcular las estadísticas descriptivas de interés. En particular, se calculan el número de personas ocupadas, desocupadas e inactivas en cada dominio, y la proporción de personas en cada una de estas categorías. La función “survey_mean” se utiliza para calcular la proporción de personas en cada una de estas categorías con sus respectivos errores estándar y efecto de diseño. indicador_dam &lt;- diseno %&gt;% group_by_at(id_dominio) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( n_ocupado = unweighted(sum(empleo == 1)), n_desocupado = unweighted(sum(empleo == 2)), n_inactivo = unweighted(sum(empleo == 3)), Ocupado = survey_mean(empleo == 1, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Desocupado = survey_mean(empleo == 2, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Inactivo = survey_mean(empleo == 3, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ) ) "],["selección-de-dominios-2.html", "10.2 Selección de dominios", " 10.2 Selección de dominios En la sección anterior, se llevó a cabo una estimación directa para cada categoría individualmente en cada municipio (dominio) presente en la muestra. Ahora, para evaluar la calidad de los resultados obtenidos, realizaremos un análisis descriptivo. Se emplean varias medidas de calidad, entre ellas, se cuenta el número de dominios que tienen dos o más unidades primarias de muestreo (UPM), así como el efecto de diseño mayor a 1 y las varianzas mayores a 0. Estas medidas nos permitirán determinar la fiabilidad de nuestros resultados y tomar decisiones informadas en función de ellos. Después de realizar las validaciones anteriores se establece como regla incluir en el estudio los dominios que posean Dos o más UPM por dominio. Contar con un resultado en el Deff Varianza estimada mayor a \\(10^{-8}\\) indicador_dam &lt;- encuesta %&gt;% select(id_dominio, upm) %&gt;% distinct() %&gt;% group_by_at(id_dominio) %&gt;% tally(name = &quot;n_upm&quot;) %&gt;% inner_join(indicador_dam, by = id_dominio) indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2, !is.na(Desocupado_deff), !is.na(Ocupado_deff), !is.na(Inactivo_deff), Desocupado_var &gt; 0.00000001, Ocupado_var &gt; 0.00000001, Inactivo_var &gt; 0.00000001 ) %&gt;% mutate(id_orden = 1:n()) # saveRDS(object = indicador_dam1, &quot;Rmd/MEX/Recursos/base_modelo.Rds&quot;) dam2 n_upm n_ocupado n_desocupado n_inactivo Ocupado Ocupado_se Ocupado_var Ocupado_deff Desocupado Desocupado_se Desocupado_var Desocupado_deff Inactivo Inactivo_se Inactivo_var Inactivo_deff id_orden 01001 274 2560 151 1609 0.5927 0.0082 1e-04 1.2035 0.0361 0.0032 0e+00 1.3006 0.3712 0.0079 1e-04 1.1630 1 01002 5 199 8 149 0.5602 0.0104 1e-04 0.1579 0.0223 0.0063 0e+00 0.6451 0.4175 0.0091 1e-04 0.1235 2 01003 8 238 18 194 0.5399 0.0158 2e-04 0.4575 0.0362 0.0075 1e-04 0.7328 0.4239 0.0138 2e-04 0.3554 3 01005 27 619 25 298 0.6365 0.0182 3e-04 1.3637 0.0352 0.0077 1e-04 1.6567 0.3283 0.0157 2e-04 1.0603 4 01006 7 273 14 194 0.5801 0.0200 4e-04 0.7957 0.0264 0.0056 0e+00 0.5836 0.3935 0.0180 3e-04 0.6536 5 01007 8 334 9 225 0.6132 0.0312 1e-03 2.3457 0.0155 0.0059 0e+00 1.3093 0.3714 0.0300 9e-04 2.2054 6 01009 2 78 2 51 0.6034 0.0225 5e-04 0.2796 0.0119 0.0095 1e-04 1.0159 0.3847 0.0130 2e-04 0.0943 7 01011 8 324 17 177 0.6359 0.0290 8e-04 1.9003 0.0298 0.0074 1e-04 0.9842 0.3343 0.0319 1e-03 2.3912 8 02001 73 1359 55 979 0.5488 0.0190 4e-04 3.5128 0.0230 0.0050 0e+00 2.6845 0.4282 0.0181 3e-04 3.2195 9 02002 141 2014 93 1644 0.5537 0.0113 1e-04 1.9590 0.0221 0.0039 0e+00 2.6821 0.4242 0.0110 1e-04 1.8694 10 "],["preparando-insumos-para-stan-2.html", "10.3 Preparando insumos para STAN", " 10.3 Preparando insumos para STAN Lectura y adecuación de covariables statelevel_satelite &lt;- readRDS(&#39;01 Modelo de area//MEX/2020/Data/satelital_media2.rds&#39;) statelevel_censo &lt;- readRDS(&#39;01 Modelo de area//MEX/2020/Data/statelevel_predictors_df_dam2.rds&#39;) statelevel_predictors_df &lt;- left_join(statelevel_satelite,statelevel_censo) ## Estandarizando las variables para controlar el efecto de la escala. statelevel_predictors_df %&lt;&gt;% mutate_at(vars(&quot;luces_nocturnas&quot;, &quot;cubrimiento_cultivo&quot;, &quot;cubrimiento_urbano&quot;, &quot;modificacion_humana&quot;, &quot;accesibilidad_hospitales&quot;, &quot;accesibilidad_hosp_caminado&quot;), function(x)as.numeric(scale(x))) Seleccionar las variables del modelo y crear matriz de covariables. names_cov &lt;- c( &quot;dam2&quot;, &quot;luces_nocturnas&quot;, &quot;cubrimiento_cultivo&quot;, &quot;cubrimiento_urbano&quot;, &quot;modificacion_humana&quot;, &quot;tasa_desocupacion&quot;, &quot;discapacidad1&quot;, &quot;rezago_escolar&quot; ) X_pred &lt;- anti_join(statelevel_predictors_df %&gt;% select(all_of(names_cov)), indicador_dam1 %&gt;% select(dam2)) En el bloque de código se identifican que dominios serán los predichos. X_pred %&gt;% select(dam2) %&gt;% saveRDS(file = &quot;01 Modelo de area/MEX/2020/Data/dam_pred.rds&quot;) Creando la matriz de covariables para los dominios no observados (X_pred) y los observados (X_obs) ## Obteniendo la matrix X_pred %&lt;&gt;% data.frame() %&gt;% select(-dam2) %&gt;% as.matrix() ## Identificando los dominios para realizar estimación del modelo X_obs &lt;- inner_join(indicador_dam1 %&gt;% select(dam2, id_orden), statelevel_predictors_df %&gt;% select(all_of(names_cov))) %&gt;% arrange(id_orden) %&gt;% data.frame() %&gt;% select(-dam2, -id_orden) %&gt;% as.matrix() Calculando el n_efectivo y el \\(\\tilde{y}\\) D &lt;- nrow(indicador_dam1) P &lt;- 3 # Ocupado, desocupado, inactivo. Y_tilde &lt;- matrix(NA, D, P) n_tilde &lt;- matrix(NA, D, P) # n efectivos ocupado n_tilde[,1] &lt;- (indicador_dam1$Ocupado*(1 - indicador_dam1$Ocupado))/indicador_dam1$Ocupado_var Y_tilde[,1] &lt;- n_tilde[,1]* indicador_dam1$Ocupado # n efectivos desocupado n_tilde[,2] &lt;- (indicador_dam1$Desocupado*(1 - indicador_dam1$Desocupado))/indicador_dam1$Desocupado_var Y_tilde[,2] &lt;- n_tilde[,2]* indicador_dam1$Desocupado # n efectivos Inactivo n_tilde[,3] &lt;- (indicador_dam1$Inactivo*(1 - indicador_dam1$Inactivo))/indicador_dam1$Inactivo_var Y_tilde[,3] &lt;- n_tilde[,3]* indicador_dam1$Inactivo Compilando el modelo X1_obs &lt;- cbind(matrix(1,nrow = D,ncol = 1),X_obs) K = ncol(X1_obs) D1 &lt;- nrow(X_pred) X1_pred &lt;- cbind(matrix(1,nrow = D1,ncol = 1),X_pred) sample_data &lt;- list(D = D, P = P, K = K, hat_y = Y_tilde, X_obs = X1_obs, X_pred = X1_pred, D1 = D1) library(rstan) fit_mcmc2 &lt;- stan( file = &quot;01 Modelo de area/0funciones/01 Multinomial_simple_pred.stan&quot;, # Stan program data = sample_data, # named list of data verbose = TRUE, warmup = 1000, # number of warmup iterations per chain iter = 2000, # total number of iterations per chain cores = 4, # number of cores (could use one per chain) ) saveRDS(fit_mcmc2, &quot;01 Modelo de area/MEX/2020/Data/fit_rtanmultinomial_con_covariable_satelite2.Rds&quot;) "],["validación-del-modelo-2.html", "10.4 Validación del modelo", " 10.4 Validación del modelo La validación de un modelo es esencial para evaluar su capacidad para predecir de manera precisa y confiable los resultados futuros. En el caso de un modelo de área con respuesta multinomial, la validación se enfoca en medir la precisión del modelo para predecir las diferentes categorías de respuesta. El objetivo principal de la validación es determinar si el modelo es capaz de generalizar bien a datos no vistos y proporcionar predicciones precisas. Esto implica comparar las predicciones del modelo con los datos observados y utilizar métricas de evaluación para medir el rendimiento del modelo. La validación del modelo es esencial para garantizar la calidad de las predicciones y la confiabilidad del modelo para su uso en aplicaciones futuras. library(posterior) infile &lt;- paste0(&quot;01 Modelo de area/MEX/2020/Data/fit_rtanmultinomial_con_covariable_satelite2.Rds&quot;) fit &lt;- readRDS(infile) theta_dir &lt;- indicador_dam1 %&gt;% transmute(dam2, n = n_desocupado + n_ocupado + n_inactivo, Ocupado, Desocupado, Inactivo) color_scheme_set(&quot;brightblue&quot;) theme_set(theme_bw(base_size = 15)) y_pred_B &lt;- as.array(fit, pars = &quot;theta&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = colnames(y_pred_B),value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = colnames(y_pred_B),value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = colnames(y_pred_B),value = TRUE) y_pred1 &lt;- y_pred_B[rowsrandom,theta_1 ] y_pred2 &lt;- y_pred_B[rowsrandom,theta_2 ] y_pred3 &lt;- y_pred_B[rowsrandom,theta_3 ] ppc_dens_overlay(y = as.numeric(theta_dir$Ocupado), y_pred1)/ ppc_dens_overlay(y = as.numeric(theta_dir$Desocupado), y_pred2)/ ppc_dens_overlay(y = as.numeric(theta_dir$Inactivo), y_pred3) La matriz de correlación de los efectos aleatorios. omega &lt;- summary(fit,&quot;Omega&quot;)$summary tba(omega) mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat Omega[1,1] 1.0000 NaN 0.0000 1.0000 1.0000 1.0000 1.0000 1.0000 NaN NaN Omega[1,2] 0.4851 0.002 0.0429 0.3976 0.4576 0.4864 0.5153 0.5639 462.4828 1.0058 Omega[2,1] 0.4851 0.002 0.0429 0.3976 0.4576 0.4864 0.5153 0.5639 462.4828 1.0058 Omega[2,2] 1.0000 0.000 0.0000 1.0000 1.0000 1.0000 1.0000 1.0000 3358.3429 0.9990 10.4.1 Estimación de los parámetros. El código crea dos matrices, theta_obs_ordenado y theta_pred_ordenado, que contienen las estimaciones medias de los parámetros del modelo de respuesta multinomial con covariables para los datos de observación y predicción, respectivamente. La función matrix() se utiliza para dar formato a los datos con una matriz nrow x ncol, y se asignan nombres de columna apropiados a la matriz resultante utilizando colnames(). Luego se convierten las matrices en marcos de datos (as.data.frame()) y se unen mediante full_join() para crear una única tabla que contenga todas las estimaciones de los parámetros para los datos de observación y predicción, junto con la información del indicador de área (theta_dir). El resultado final es un marco de datos llamado estimaciones_obs. dam_pred &lt;- readRDS(&quot;01 Modelo de area/MEX/2020/Data/dam_pred.rds&quot;) P &lt;- 3 D &lt;- nrow(indicador_dam1) D1 &lt;- nrow(dam_pred) ## Estimación del modelo. theta_obs &lt;- summary(fit, pars = &quot;theta&quot;)$summary[, &quot;mean&quot;] theta_pred &lt;- summary(fit, pars = &quot;theta_pred&quot;)$summary[, &quot;mean&quot;] ## Ordenando la matrix de theta theta_obs_ordenado &lt;- matrix(theta_obs, nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_obs_ordenado%&lt;&gt;% as.data.frame() theta_obs_ordenado &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado) theta_pred_ordenado &lt;- matrix(theta_pred, nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_pred_ordenado%&lt;&gt;% as.data.frame() theta_pred_ordenado &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado) 10.4.1.1 Estimación del desviación estárdar y el coeficiente de valiación Este bloque de código corresponde al cálculo de las desviaciones estándar (sd) y coeficientes de variación (cv) de los parámetros theta para los datos observados y predichos. En primer lugar, se utiliza la función summary() del paquete rstan para extraer los valores de sd de los parámetros theta observados y predichos, respectivamente, a partir del modelo (fit) que contiene la información de la estimación de los parámetros de la distribución Bayesiana. Luego, se organizan los valores de sd en una matriz ordenada por dam2 y se les asignan los nombres correspondientes. Con esta matriz, se calcula otra matriz que contiene los coeficientes de variación para los parámetros theta observados (theta_obs_ordenado_cv). De manera similar, se construyen matrices ordenadas por dam2 para los valores de sd y cv de los parámetros theta predichos (theta_pred_ordenado_sd y theta_pred_ordenado_cv, respectivamente). theta_obs_sd &lt;- summary(fit, pars = &quot;theta&quot;)$summary[, &quot;sd&quot;] theta_pred_sd &lt;- summary(fit, pars = &quot;theta_pred&quot;)$summary[, &quot;sd&quot;] theta_obs_ordenado_sd &lt;- matrix(theta_obs_sd, nrow = D, ncol = P,byrow = TRUE) colnames(theta_obs_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_obs_ordenado_sd%&lt;&gt;% as.data.frame() theta_obs_ordenado_sd &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_sd) theta_obs_ordenado_cv &lt;- theta_obs_ordenado_sd[,-1]/theta_obs_ordenado[,-1] colnames(theta_obs_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_obs_ordenado_cv &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_cv) theta_pred_ordenado_sd &lt;- matrix(theta_pred_sd, nrow = D1, ncol = P,byrow = TRUE) colnames(theta_pred_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_pred_ordenado_sd%&lt;&gt;% as.data.frame() theta_pred_ordenado_sd &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_sd) theta_pred_ordenado_cv &lt;- theta_pred_ordenado_sd[,-1]/theta_pred_ordenado[,-1] colnames(theta_pred_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_pred_ordenado_cv &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_cv) El último paso es realizar la consolidación de la bases obtenidas para la estimación puntual, desviación estándar y coeficiente de variación. theta_obs_ordenado &lt;- full_join(theta_obs_ordenado,theta_obs_ordenado_sd) %&gt;% full_join(theta_obs_ordenado_cv) theta_pred_ordenado &lt;- full_join(theta_pred_ordenado,theta_pred_ordenado_sd) %&gt;% full_join(theta_pred_ordenado_cv) estimaciones &lt;- full_join(indicador_dam1, bind_rows(theta_obs_ordenado, theta_pred_ordenado)) saveRDS(object = estimaciones, file = &quot;Rmd/MEX/Recursos/estimaciones.rds&quot;) tba(head(estimaciones,10)) dam2 n_upm n_ocupado n_desocupado n_inactivo Ocupado Ocupado_se Ocupado_var Ocupado_deff Desocupado Desocupado_se Desocupado_var Desocupado_deff Inactivo Inactivo_se Inactivo_var Inactivo_deff id_orden Ocupado_mod Desocupado_mod Inactivo_mod Ocupado_mod_sd Desocupado_mod_sd Inactivo_mod_sd Ocupado_mod_cv Desocupado_mod_cv Inactivo_mod_cv 01001 274 2560 151 1609 0.5927 0.0082 1e-04 1.2035 0.0361 0.0032 0e+00 1.3006 0.3712 0.0079 1e-04 1.1630 1 0.5921 0.0358 0.3721 0.0079 0.0030 0.0078 0.0134 0.0840 0.0210 01002 5 199 8 149 0.5602 0.0104 1e-04 0.1579 0.0223 0.0063 0e+00 0.6451 0.4175 0.0091 1e-04 0.1235 2 0.5611 0.0225 0.4164 0.0098 0.0028 0.0097 0.0175 0.1254 0.0233 01003 8 238 18 194 0.5399 0.0158 2e-04 0.4575 0.0362 0.0075 1e-04 0.7328 0.4239 0.0138 2e-04 0.3554 3 0.5414 0.0342 0.4244 0.0149 0.0051 0.0148 0.0275 0.1489 0.0348 01005 27 619 25 298 0.6365 0.0182 3e-04 1.3637 0.0352 0.0077 1e-04 1.6567 0.3283 0.0157 2e-04 1.0603 4 0.6306 0.0335 0.3360 0.0169 0.0060 0.0164 0.0268 0.1804 0.0487 01006 7 273 14 194 0.5801 0.0200 4e-04 0.7957 0.0264 0.0056 0e+00 0.5836 0.3935 0.0180 3e-04 0.6536 5 0.5805 0.0269 0.3926 0.0176 0.0054 0.0172 0.0304 0.2023 0.0437 01007 8 334 9 225 0.6132 0.0312 1e-03 2.3457 0.0155 0.0059 0e+00 1.3093 0.3714 0.0300 9e-04 2.2054 6 0.6089 0.0205 0.3706 0.0273 0.0063 0.0264 0.0449 0.3091 0.0711 01009 2 78 2 51 0.6034 0.0225 5e-04 0.2796 0.0119 0.0095 1e-04 1.0159 0.3847 0.0130 2e-04 0.0943 7 0.6023 0.0152 0.3825 0.0167 0.0035 0.0163 0.0278 0.2332 0.0426 01011 8 324 17 177 0.6359 0.0290 8e-04 1.9003 0.0298 0.0074 1e-04 0.9842 0.3343 0.0319 1e-03 2.3912 8 0.6252 0.0291 0.3458 0.0264 0.0081 0.0252 0.0422 0.2783 0.0730 02001 73 1359 55 979 0.5488 0.0190 4e-04 3.5128 0.0230 0.0050 0e+00 2.6845 0.4282 0.0181 3e-04 3.2195 9 0.5493 0.0253 0.4253 0.0175 0.0050 0.0172 0.0318 0.1989 0.0404 02002 141 2014 93 1644 0.5537 0.0113 1e-04 1.9590 0.0221 0.0039 0e+00 2.6821 0.4242 0.0110 1e-04 1.8694 10 0.5537 0.0234 0.4229 0.0110 0.0033 0.0109 0.0199 0.1419 0.0258 "],["metodología-de-benchmarking-2.html", "10.5 Metodología de Benchmarking", " 10.5 Metodología de Benchmarking Conteos de personas agregados por dam2, personas mayores de 15 años de edad. conteo_pp_dam &lt;- readRDS(&quot;01 Modelo de area/MEX/2020/Data/censo_dam2.rds&quot;) %&gt;% filter(edad &gt; 1) %&gt;% group_by(dam = depto, dam2 = mpio) %&gt;% summarise(pp_dam2 = sum(n)) %&gt;% add_tally(wt = pp_dam2, name = &quot;pp_dam&quot;) Estimación del parámetro theta al nivel que la encuesta sea representativa. indicador_agregado &lt;- readRDS(&quot;Rmd/MEX/Recursos/indicador_agregado.rds&quot;) tba(indicador_agregado %&gt;% head(10)) dam Ocupado Desocupado Inactivo 01 0.5974 0.0336 0.3690 02 0.5552 0.0276 0.4172 03 0.5824 0.0297 0.3879 04 0.6429 0.0205 0.3365 05 0.5331 0.0352 0.4316 06 0.6115 0.0239 0.3645 07 0.6799 0.0158 0.3043 08 0.5465 0.0316 0.4219 09 0.5142 0.0601 0.4257 10 0.5668 0.0303 0.4030 Razon_empleo &lt;- readRDS(&quot;Rmd/MEX/Recursos/Razon_empleo.rds&quot;) Definir los pesos por dominios. names_cov &lt;- &quot;dam&quot; estimaciones_mod &lt;- estimaciones %&gt;% transmute( dam = substr(dam2,1,2), dam2,Ocupado_mod,Desocupado_mod,Inactivo_mod) %&gt;% inner_join(conteo_pp_dam ) %&gt;% mutate(wi = pp_dam2/pp_dam) Crear variables dummys estimaciones_mod %&lt;&gt;% fastDummies::dummy_cols(select_columns = names_cov, remove_selected_columns = FALSE) Xdummy &lt;- estimaciones_mod %&gt;% select(matches(&quot;dam_&quot;)) %&gt;% mutate_at(vars(matches(&quot;_\\\\d&quot;)) , list(Ocupado = function(x) x*estimaciones_mod$Ocupado_mod, Desocupado = function(x) x*estimaciones_mod$Desocupado_mod, Inactivo = function(x) x*estimaciones_mod$Inactivo_mod)) %&gt;% select((matches(&quot;Ocupado|Desocupado|Inactivo&quot;))) Calcular el ponderador para cada nivel de la variable. Ocupado names_ocupado &lt;- grep(pattern = &quot;_O&quot;, x = colnames(Xdummy),value = TRUE) gk_ocupado &lt;- calib(Xs = Xdummy[,names_ocupado] %&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_ocupado] %&gt;% as.matrix(), method=&quot;logit&quot;,max_iter = 5000) checkcalibration(Xs = Xdummy[,names_ocupado] %&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_ocupado] %&gt;% as.matrix(), g = gk_ocupado) Desocupado names_descupados &lt;- grep(pattern = &quot;_D&quot;, x = colnames(Xdummy),value = TRUE) gk_desocupado &lt;- calib(Xs = Xdummy[,names_descupados]%&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_descupados]%&gt;% as.matrix(), method=&quot;logit&quot;,max_iter = 5000) checkcalibration(Xs = Xdummy[,names_descupados]%&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_descupados]%&gt;% as.matrix(), g = gk_desocupado,) Inactivo names_inactivo &lt;- grep(pattern = &quot;_I&quot;, x = colnames(Xdummy),value = TRUE) gk_Inactivo &lt;- calib(Xs = Xdummy[,names_inactivo]%&gt;% as.matrix(), d = estimaciones_mod$wi, total = Razon_empleo[names_inactivo]%&gt;% as.matrix(), method=&quot;logit&quot;,max_iter = 5000) checkcalibration(Xs = Xdummy[,names_inactivo]%&gt;% as.matrix(), d =estimaciones_mod$wi, total = Razon_empleo[names_inactivo]%&gt;% as.matrix(), g = gk_Inactivo,) Validar los resultados obtenidos. par(mfrow = c(1,3)) hist(gk_ocupado) hist(gk_desocupado) hist(gk_Inactivo) Estimaciones ajustadas por el ponderador estimacionesBench &lt;- estimaciones_mod %&gt;% mutate(gk_ocupado, gk_desocupado, gk_Inactivo) %&gt;% transmute( dam, dam2, wi,gk_ocupado, gk_desocupado, gk_Inactivo, Ocupado_Bench = Ocupado_mod*gk_ocupado, Desocupado_Bench = Desocupado_mod*gk_desocupado, Inactivo_Bench = Inactivo_mod*gk_Inactivo ) Validación de resultados. estimacionesBench %&gt;% group_by(dam) %&gt;% summarise(Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) %&gt;% inner_join(indicador_agregado) %&gt;% tba() dam Ocupado_Bench Desocupado_Bench Inactivo_Bench Ocupado Desocupado Inactivo 01 0.5974 0.0336 0.3690 0.5974 0.0336 0.3690 02 0.5552 0.0276 0.4172 0.5552 0.0276 0.4172 03 0.5824 0.0297 0.3879 0.5824 0.0297 0.3879 04 0.6429 0.0205 0.3365 0.6429 0.0205 0.3365 05 0.5331 0.0352 0.4316 0.5331 0.0352 0.4316 06 0.6115 0.0239 0.3645 0.6115 0.0239 0.3645 07 0.6799 0.0158 0.3043 0.6799 0.0158 0.3043 08 0.5465 0.0316 0.4219 0.5465 0.0316 0.4219 09 0.5142 0.0601 0.4257 0.5142 0.0601 0.4257 10 0.5668 0.0303 0.4030 0.5668 0.0303 0.4030 11 0.5666 0.0334 0.4000 0.5666 0.0334 0.4000 12 0.6310 0.0195 0.3495 0.6310 0.0195 0.3495 13 0.6044 0.0216 0.3740 0.6044 0.0216 0.3740 14 0.5697 0.0356 0.3946 0.5697 0.0356 0.3946 15 0.5290 0.0428 0.4282 0.5290 0.0428 0.4282 16 0.6337 0.0185 0.3478 0.6337 0.0185 0.3478 17 0.5972 0.0285 0.3743 0.5972 0.0285 0.3743 18 0.6331 0.0204 0.3466 0.6331 0.0204 0.3466 19 0.5429 0.0366 0.4205 0.5429 0.0366 0.4205 20 0.6686 0.0130 0.3184 0.6686 0.0130 0.3184 21 0.6505 0.0261 0.3234 0.6505 0.0261 0.3234 22 0.5746 0.0338 0.3916 0.5746 0.0338 0.3916 23 0.5785 0.0433 0.3782 0.5785 0.0433 0.3782 24 0.5796 0.0272 0.3932 0.5796 0.0272 0.3932 25 0.5385 0.0310 0.4305 0.5385 0.0310 0.4305 26 0.5615 0.0324 0.4061 0.5615 0.0324 0.4061 27 0.5990 0.0301 0.3709 0.5990 0.0301 0.3709 28 0.5416 0.0295 0.4289 0.5416 0.0295 0.4289 29 0.5928 0.0263 0.3809 0.5928 0.0263 0.3809 30 0.5971 0.0200 0.3829 0.5971 0.0200 0.3829 31 0.6536 0.0193 0.3271 0.6536 0.0193 0.3271 32 0.5875 0.0132 0.3993 0.5875 0.0132 0.3993 Guardar resultados estimaciones &lt;- inner_join(estimaciones,estimacionesBench) saveRDS(object = estimaciones, file = &quot;Rmd/MEX/Recursos/estimaciones_Bench.rds&quot;) "],["mapas-del-mercado-de-trabajo.-2.html", "10.6 Mapas del mercado de trabajo.", " 10.6 Mapas del mercado de trabajo. library(sp) library(sf) library(tmap) ShapeSAE &lt;- read_sf(&quot;01 Modelo de area/MEX/2020/Shape/MEX_dam2.shp&quot;) P1_empleo &lt;- tm_shape(ShapeSAE %&gt;% inner_join(estimaciones)) brks_ocupado &lt;- seq(0,1,0.2) brks_desocupado &lt;- seq(0,0.1,0.02) brks_inactivo &lt;- seq(0.10,0.9, 0.2) Ocupado Mapa_ocupado &lt;- P1_empleo + tm_fill(&quot;Ocupado_Bench&quot;, breaks = brks_ocupado, title = &quot;Ocupado&quot;, palette = &quot;-Blues&quot;) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3 ) Mapa_ocupado Desocupado Mapa_desocupado &lt;- P1_empleo + tm_fill( &quot;Desocupado_Bench&quot;, breaks = brks_desocupado, title = &quot;Desocupado&quot;, palette = &quot;YlOrRd&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Mapa_desocupado Inactivo Mapa_Inactivo &lt;- P1_empleo + tm_fill( &quot;Inactivo_Bench&quot;, title = &quot;Inactivo&quot;, breaks = brks_inactivo, palette = &quot;YlGn&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
