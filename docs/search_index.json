[["index.html", "Estimación de áreas pequeñas con el modelo multinomial Prefacio", " Estimación de áreas pequeñas con el modelo multinomial Andrés Gutiérrez, Stalyn Guerrero, Carolina Franco, Charlotte Taglioni Prefacio knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["estimación-directa-para-las-comunas-de-chile..html", "Capítulo 1 Estimación directa para las comunas de Chile.", " Capítulo 1 Estimación directa para las comunas de Chile. La Encuesta de Caracterización Socioeconómica Nacional (CASEN) de Chile 2017. Los niveles de estimación o dominios de estudio para los cuales la muestra fue representativa son: nacional, nacional urbano, nacional rural y regional. El diseño corresponde a una muestra probabilística, estratificada y bietápica, siendo los estratos conformados por la dupla Comuna-Área. La base de datos de la encuesta cuenta con 216439 registros, distribuidos en 1637 upm "],["lectura-de-la-encuesta..html", "1.1 Lectura de la encuesta.", " 1.1 Lectura de la encuesta. Para el procesamiento de la información se emplea el archivo de la encuesta disponible en los repositorios de CEPAL, las cuales han sido estandarizadas previamente. El proceso de la lectura inicia con el cargue de las siguientes librerías. TeachingSampling: Esta librería proporciona herramientas para la enseñanza y práctica de métodos de muestreo. Incluye funciones para generar diseños de muestreo, realizar muestreo aleatorio simple y estratificado, entre otros. survey: Esta librería proporciona herramientas para el análisis de datos de encuestas complejas. Permite crear y manejar diseños de muestreo, ajustar modelos estadísticos a datos de encuestas, estimar errores estándar y realizar pruebas de hipótesis. Es especialmente útil para datos de encuestas que involucren estratificación, conglomerados o ponderación. tidyverse: Esta librería es un conjunto de paquetes diseñados para trabajar juntos y facilitar la manipulación, visualización y modelado de datos en R. Incluye ggplot2 para gráficos, dplyr para manipulación de datos, tidyr para limpieza de datos, readr para lectura de datos, entre otros. srvyr: Esta librería extiende la funcionalidad de la librería survey, permitiendo el uso de la sintaxis “tidyverse” en el análisis de datos de encuestas complejas. Permite la manipulación y visualización de datos de encuestas mediante la integración con el paquete dplyr. haven: Esta librería proporciona herramientas para la lectura, escritura y manejo de datos en formato SPSS, SAS y Stata. Permite la importación y exportación de datos entre R y otros programas estadísticos, así como la manipulación de metadatos y variables etiquetadas. library(survey) library(tidyverse) library(srvyr) library(TeachingSampling) library(haven) La lectura de la base es realizada con la siguiente linea de código. encuesta &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/encuesta_2017.Rds&#39;) El siguiente código realiza una serie de transformaciones de datos utilizando el paquete tidyverse. Primero, se asigna a la variable length_upm la longitud máxima de los valores en la columna _upm de la encuesta. De manera similar, se asigna a la variable length_estrato la longitud máxima de los valores en la columna _estrato. Luego, se utiliza la función transmute() para crear nuevas variables y modificar las existentes. Se crea la variable dam (División Administrativa Mayor) a partir de la columna dam_ee, se convierte en factor y se utiliza la función str_pad() para agregar ceros a la izquierda hasta que tenga una longitud de 2 caracteres. De manera similar, se crea la variable dam2 a partir de la columna comuna, se convierte en factor y se utiliza la función str_pad() para agregar ceros a la izquierda hasta que tenga una longitud de 5 caracteres. También se crean variables nombre_dam y nombre_dam2 a partir de las mismas columnas dam_ee y comuna, respectivamente, pero se convierten en factores que utilizan los valores y etiquetas específicas. Se crea la variable upm a partir de la columna _upm, se utiliza la función str_pad() para agregar ceros a la izquierda hasta que tenga una longitud igual a length_upm. Se crea la variable estrato de manera similar a partir de la columna _estrato y utilizando length_estrato. Finalmente, se crean las variables fep y empleo, que se asignan a las columnas _fep y condact3, respectivamente. El resultado final es un conjunto de datos transformado con nuevas variables creadas y algunas columnas modificadas. ## length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string = dam, width = 2, pad = &quot;0&quot;), dam2 = as_factor(comuna,levels = &quot;values&quot;), dam2 = str_pad(string =dam2, width = 5, pad = &quot;0&quot;), nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), nombre_dam2 = as_factor(comuna,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = as_factor(condact3,levels = &quot;values&quot;), etiquetas_empleo = as_factor(condact3, levels = &quot;labels&quot;) ) head(encuesta, 10) %&gt;% tba(cap = &quot;Encuesta trasnformada&quot;) Tabla 1.1: Encuesta trasnformada dam dam2 nombre_dam nombre_dam2 upm estrato fep empleo etiquetas_empleo 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 3 Inactivo 01 01101 Tarapacá Iquique 01100100001 011001 39 -1 NA 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 2 Desocupado 01 01101 Tarapacá Iquique 01100100001 011001 39 1 Ocupado Realizando algunas validaciones sobre la base de datos: encuesta %&gt;% group_by( empleo, etiquetas_empleo) %&gt;% tally() %&gt;% tba(cap = &quot;Niveles de la variable empleo&quot;) Tabla 1.2: Niveles de la variable empleo empleo etiquetas_empleo n -1 NA 41363 1 Ocupado 92417 2 Desocupado 8671 3 Inactivo 73567 9 NR 421 "],["definición-del-diseño-muestral.html", "1.2 Definición del diseño muestral", " 1.2 Definición del diseño muestral El primer comando options establece una opción global para el paquete survey, que se utiliza para realizar análisis de datos con muestreo complejo. En este caso, se establece la opción survey.lonely.psu en “adjust”, lo que significa que los PSUs (unidades primarias de muestreo) solitarios se ajustarán automáticamente en los análisis. El segundo comando crea un objeto de diseño de encuesta utilizando el paquete srvyr, a partir del conjunto de datos encuesta previamente transformado. La función as_survey_design() toma varios argumentos que especifican cómo se realizó el diseño de la encuesta. En este caso, se especifica que la variable estrato se utiliza como estrato, la variable upm se utiliza como identificador de PSU, y la variable fep se utiliza como peso de muestreo. También se establece el argumento nest en TRUE para indicar que el objeto de diseño incluirá los datos anidados dentro de cada PSU. options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) "],["estimación-directa-del-indicador.html", "1.3 Estimación directa del indicador", " 1.3 Estimación directa del indicador Para realizar la estimación directa para cada dominio de la variable dam2 en el objeto de diseño diseno se emplea el siguiente código. Primero, el objeto de diseño se agrupa por la variable dam2 utilizando la función group_by_at(). Luego, se filtran las observaciones para incluir solo aquellas en las que la variable empleo es igual a 1, 2 o 3 (es decir, ocupado, desocupado o inactivo, respectivamente) utilizando la función filter(). A continuación, se utilizan las funciones sum() y unweighted para calcular el número de observaciones en cada nivel de la variable empleo. Luego, se utilizan las funciones survey_mean() para calcular la media del indicador de empleo en cada nivel de la variable empleo (es decir, la proporción de personas ocupadas, desocupadas e inactivas). Los argumentos vartype = c(\"se\", \"var\") y deff = T se utilizan para estimar el error estándar y la varianza de la media; el efecto del diseño, respectivamente. indicador_dam &lt;- diseno %&gt;% group_by_at(&quot;dam2&quot;) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( n_ocupado = unweighted(sum(empleo == 1)), n_desocupado = unweighted(sum(empleo == 2)), n_inactivo = unweighted(sum(empleo == 3)), Ocupado = survey_mean(empleo == 1, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Desocupado = survey_mean(empleo == 2, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ), Inactivo = survey_mean(empleo == 3, vartype = c(&quot;se&quot;, &quot;var&quot;), deff = T ) ) indicador_dam %&gt;% select(dam2,Ocupado,Desocupado,Inactivo) %&gt;% head(10) %&gt;% tba(cap = &quot;Estimación directa&quot;) Tabla 1.3: Estimación directa dam2 Ocupado Desocupado Inactivo 01101 0.5975 0.0478 0.3547 01107 0.5619 0.0539 0.3842 01401 0.5369 0.0499 0.4133 01402 0.7529 0.0000 0.2471 01404 0.5772 0.0095 0.4132 01405 0.5630 0.0188 0.4182 02101 0.5448 0.0557 0.3995 02102 0.6002 0.0680 0.3319 02103 0.6766 0.0838 0.2397 02104 0.5391 0.0576 0.4034 Ahora, se realiza el conteo de las PSU por dominios y se incorpora la información a la base que resulta del paso anterior. indicador_dam &lt;- encuesta %&gt;% dplyr::select(dam2, upm) %&gt;% distinct() %&gt;% group_by(dam2) %&gt;% tally(name = &quot;n_upm&quot;) %&gt;% inner_join(indicador_dam, by = &quot;dam2&quot;) Guardar los archivos resultantes saveRDS(indicador_dam,&#39;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&#39; ) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["análisis-descriptivo-de-las-estimaciones-directas..html", "Capítulo 2 Análisis descriptivo de las estimaciones directas. ", " Capítulo 2 Análisis descriptivo de las estimaciones directas. "],["lectura-de-librerías.html", "2.1 Lectura de librerías", " 2.1 Lectura de librerías library(ggplot2) library(dplyr) library(patchwork) library(kableExtra) select &lt;- dplyr::select "],["definiendo-algunas-funciones-útiles..html", "2.2 Definiendo algunas funciones útiles.", " 2.2 Definiendo algunas funciones útiles. NAs_deff &lt;- function(x){sum(is.na(x))} cont_deff &lt;- function(x){deff = sum(x&gt;1,na.rm = TRUE)} cont_deff_upm &lt;- function(x, nupm) { deff = sum(x &gt; 1 &amp; nupm &gt;= 2, na.rm = TRUE) } var_conteo &lt;- function(x)sum(x&gt;0)/length(x) "],["lectura-de-las-estimaciones-directas.html", "2.3 Lectura de las estimaciones directas", " 2.3 Lectura de las estimaciones directas indicador_dam &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&#39;) "],["descriptivo-de-las-estimaciones-directas.html", "2.4 Descriptivo de las estimaciones directas", " 2.4 Descriptivo de las estimaciones directas 2.4.1 Conteo de los dominios con deff no estimados indicador_dam %&gt;% summarise_at(.vars = vars(matches(&quot;_deff&quot;)), NAs_deff) %&gt;% tba() Ocupado_deff Desocupado_deff Inactivo_deff 0 5 0 2.4.2 Conteo de los dominios con deff mayores que 1 indicador_dam %&gt;% summarise_at(.vars =vars( matches(&quot;_deff&quot;)), cont_deff) %&gt;% tba() Ocupado_deff Desocupado_deff Inactivo_deff 153 134 162 2.4.3 Porcentaje de dominios con estimación de la varianza mayor a 0 indicador_dam %&gt;% summarise_at(.vars = vars( matches(&quot;_var&quot;)), var_conteo) %&gt;% tba() Ocupado_var Desocupado_var Inactivo_var 1 0.9846 0.9969 2.4.4 Número de dominios con 2 o más upm sum(indicador_dam$n_upm&gt;=2) ## [1] 310 2.4.5 Conteo de dominios con dos o más upm y deff mayor 1 simultáneamente. indicador_dam %&gt;% summarise_at( .vars = vars(matches(&quot;_deff&quot;)), cont_deff_upm , nupm = indicador_dam$n_upm ) %&gt;%tba() Ocupado_deff Desocupado_deff Inactivo_deff 153 134 162 2.4.6 Selección de los dominios que empleamos en el modelo de área. indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2, !is.na(Desocupado_deff)) 2.4.7 Guardar archivos saveRDS(object = indicador_dam1, &quot;01 Modelo de area/CHL/2017/Data/base_modelo.Rds&quot;) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["estimación-del-modelo-de-área-de-respuesta-multinomial.html", "Capítulo 3 Estimación del modelo de área de respuesta multinomial ", " Capítulo 3 Estimación del modelo de área de respuesta multinomial "],["lectura-de-librerías-1.html", "3.1 Lectura de librerías", " 3.1 Lectura de librerías library(survey) library(srvyr) library(stringr) library(magrittr) library(ggplot2) library(patchwork) library(tidyverse) library(cmdstanr) library(bayesplot) select &lt;- dplyr::select 3.1.1 Lectura de bases de datos indicador_dam &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/base_modelo.Rds&#39;) statelevel_predictors_df &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/satelitales_media.rds&#39;) "],["estandarizando-las-variables-para-controlar-el-efecto-de-la-escala..html", "3.2 Estandarizando las variables para controlar el efecto de la escala.", " 3.2 Estandarizando las variables para controlar el efecto de la escala. statelevel_predictors_df %&lt;&gt;% mutate_if(is.numeric, function(x)as.numeric(scale(x))) "],["realizando-ajuste-sobre-el-deff-estimado..html", "3.3 Realizando ajuste sobre el deff estimado.", " 3.3 Realizando ajuste sobre el deff estimado. indicador_dam1 &lt;- indicador_dam %&gt;% mutate( id_orden = 1:n(), Ocupado_deff = ifelse(Ocupado_deff &lt; 1, 1, Ocupado_deff), Desocupado_deff = ifelse(Desocupado_deff &lt; 1, 1, Desocupado_deff), Inactivo_deff = ifelse(Inactivo_deff &lt; 1, 1, Inactivo_deff) ) "],["definición-del-modelo-multinomial.html", "3.4 Definición del modelo multinomial", " 3.4 Definición del modelo multinomial Sea \\(K\\) el número de categorías de la variable de interés \\(\\sim multinimial\\left(\\boldsymbol{\\theta}\\right)\\), con \\(\\boldsymbol{\\theta}=\\left(p_{1},p_{2},\\dots ,p_{k}\\right)\\) y \\(\\sum_{k=1}^{K}p_{k}=1\\). Sea \\(N_i\\) el número de elementos en el i-ésiamo dominio y \\(N_{ik}\\) el número de elementos que tienen la k-ésima categoría, note que \\(\\sum_{k=1}^{K}N_{ik}=N_{i}\\) y \\(p_{ik}=\\frac{N_{ik}}{N_{i}}\\). Sea \\(\\hat{p}_{ik}\\) la estimación directa de \\(p_{ik}\\) y \\(v_{ik}=Var\\left(\\hat{p}_{ik}\\right)\\) y denote el estimador de la varianza por \\(\\hat{v}_{ik}=\\widehat{Var}\\left(\\hat{p}_{ik}\\right)\\) Note que el efecto diseño cambia entre categoría, por tanto, lo primero será definir el tamaño de muestra efectivo por categoría. Esto es: La estimación de \\(\\tilde{n}\\) esta dado por \\(\\tilde{n}_{ik} = \\frac{(\\tilde{p}_{ik}\\times(1-\\tilde{p}_{ik}))}{\\hat{v}_{ik}},\\) \\(\\tilde{y}_{ik}=\\tilde{n}_{ik}\\times\\hat{p}_{ik}\\) luego, \\(\\hat{n}_{i} = \\sum_{k=1}^{K}\\tilde{y}_{ik}\\) de donde se sigue que \\(\\hat{y}_{ik} = \\hat{n}_i\\times \\hat{p}_{ik}\\) Sea \\(\\boldsymbol{\\theta}=\\left(p_{1},p_{2}, p_{3}\\right)^{T}=\\left(\\frac{N_{i1}}{N_{i}},\\frac{N_{i2}}{N_{i}}\\frac{N_{i3}}{N_{i}}\\right)^{T}\\), entonces el modelo multinomial para el i-ésimo dominio estaría dado por: \\[ \\left(\\tilde{y}_{i1},\\tilde{y}_{i2},\\tilde{y}_{i3}\\right)\\mid\\hat{n}_{i},\\boldsymbol{\\theta}_{i}\\sim multinomial\\left(\\hat{n}_{i},\\boldsymbol{\\theta}_{i}\\right) \\] Ahora, puede escribir \\(p_{ik}\\) como : \\(\\ln\\left(\\frac{p_{i2}}{p_{i1}}\\right)=\\boldsymbol{X}_{i}^{T}\\beta_{2} + u_{i2}\\) y \\(\\ln\\left(\\frac{p_{i3}}{p_{i1}}\\right)=\\boldsymbol{X}_{i}^{T}\\beta_{3}+ u_{i3}\\) Dada la restricción \\(1 = p_{i1} + p_{i2} + p_{i3}\\) entonces \\[p_{i1} + p_{i1}(e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2})+p_{i1}(e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta}_{3}} + u_{i3})\\] de donde se sigue que \\[ p_{i1}=\\frac{1}{1+e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2}+e^{\\boldsymbol{X_{i}}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i3}} \\] Las expresiones para \\(p_{i2}\\) y \\(p_{i3}\\) estarían dadas por: \\[ p_{i2}=\\frac{e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta}_{2}} + u_{i2}}{1+e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2}+e^{\\boldsymbol{X_{i}}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i3}} \\] \\[ p_{i3}=\\frac{e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta}_{3}}+ u_{i3}}{1+e^{\\boldsymbol{X}_{i}^{T}\\boldsymbol{\\beta_{2}}}+ u_{i2}+e^{\\boldsymbol{X_{i}}^{T}\\boldsymbol{\\beta_{3}}}+ u_{i3}} \\] dado la naturaleza de la variable, se puede suponer que \\(cor(u_{i2},u_{i3})\\ne 0\\) "],["modelo-programando-en-stan.html", "3.5 Modelo programando en STAN", " 3.5 Modelo programando en STAN functions { matrix pred_theta(matrix Xp, int p, matrix beta){ int D1 = rows(Xp); real num1[D1, p]; real den1[D1]; matrix[D1,p] theta_p; for(d in 1:D1){ num1[d, 1] = 1; num1[d, 2] = exp(Xp[d, ] * beta[1, ]&#39; ) ; num1[d, 3] = exp(Xp[d, ] * beta[2, ]&#39; ) ; den1[d] = sum(num1[d, ]); } for(d in 1:D1){ for(i in 2:p){ theta_p[d, i] = num1[d, i]/den1[d]; } theta_p[d, 1] = 1/den1[d]; } return theta_p ; } } data { int&lt;lower=1&gt; D; // número de dominios int&lt;lower=1&gt; P; // categorías int&lt;lower=1&gt; K; // cantidad de regresores int hat_y[D, P]; // estimaciones directa matrix[D, K] X_obs; // matriz de covariables int&lt;lower=1&gt; D1; // número de dominios no observados matrix[D1, K] X_pred; // matriz de covariables para los no observados } parameters { matrix[P-1, K] beta;// matriz de parámetros vector&lt;lower=0&gt;[P-1] sigma_u; // random effects standard deviations // declare L_u to be the Choleski factor of a 2x2 correlation matrix cholesky_factor_corr[P-1] L_u; matrix[P-1, D] z_u; } transformed parameters { simplex[P] theta[D];// vector de parámetros; real num[D, P]; real den[D]; // this transform random effects so that they have the correlation // matrix specified by the correlation matrix above matrix[P-1, D] u; // random effect matrix u = diag_pre_multiply(sigma_u, L_u) * z_u; for(d in 1:D){ num[d, 1] = 1; num[d, 2] = exp(X_obs[d, ] * beta[1, ]&#39; + u[1, d]) ; num[d, 3] = exp(X_obs[d, ] * beta[2, ]&#39; + u[2, d]) ; den[d] = sum(num[d, ]); } for(d in 1:D){ for(p in 2:P){ theta[d, p] = num[d, p]/den[d]; } theta[d, 1] = 1/den[d]; } } model { L_u ~ lkj_corr_cholesky(1); // LKJ prior for the correlation matrix to_vector(z_u) ~ normal(0, 10000); // sigma_u ~ cauchy(0, 50); sigma_u ~ inv_gamma(0.0001, 0.0001); for(p in 2:P){ for(k in 1:K){ beta[p-1, k] ~ normal(0, 10000); } } for(d in 1:D){ target += multinomial_lpmf(hat_y[d, ] | theta[d, ]); } } generated quantities { matrix[D1,P] theta_pred; matrix[2, 2] Omega; vector&lt;lower=0&gt;[2] sdcomprobar; sdcomprobar[1] = sd(u[1, ]); sdcomprobar[2] = sd(u[2, ]); Omega = L_u * L_u&#39;; // so that it return the correlation matrix theta_pred = pred_theta(X_pred, P, beta); } "],["identificando-los-municipios-para-predicción.html", "3.6 Identificando los municipios para predicción", " 3.6 Identificando los municipios para predicción X_pred &lt;- anti_join(statelevel_predictors_df, indicador_dam1 %&gt;% select(dam2)) Guardar el identificador de municipio a predecir. X_pred %&gt;% select(dam2) %&gt;% saveRDS(file = &quot;01 Modelo de area/CHL/2017/Data/dam_pred.rds&quot;) "],["obteniendo-la-matriz.html", "3.7 Obteniendo la matriz", " 3.7 Obteniendo la matriz X_pred %&lt;&gt;% data.frame() %&gt;% select(-dam2) %&gt;% as.matrix() "],["identificando-los-dominios-para-realizar-estimación-del-modelo.html", "3.8 Identificando los dominios para realizar estimación del modelo", " 3.8 Identificando los dominios para realizar estimación del modelo X_obs &lt;- inner_join(indicador_dam1 %&gt;% select(dam2, id_orden), statelevel_predictors_df) %&gt;% arrange(id_orden) %&gt;% data.frame() %&gt;% select(-dam2, -id_orden) %&gt;% as.matrix() "],["identificando-los-argumentos-para-stan.html", "3.9 Identificando los argumentos para STAN", " 3.9 Identificando los argumentos para STAN D &lt;- nrow(indicador_dam1) P &lt;- 3 # Ocupado, desocupado, inactivo. Y_tilde &lt;- matrix(NA, D, P) n_tilde &lt;- matrix(NA, D, P) Y_hat &lt;- matrix(NA, D, P) # n efectivos ocupado n_tilde[,1] &lt;- (indicador_dam1$Ocupado*(1 - indicador_dam1$Ocupado))/indicador_dam1$Ocupado_var Y_tilde[,1] &lt;- n_tilde[,1]* indicador_dam1$Ocupado # n efectivos desocupado n_tilde[,2] &lt;- (indicador_dam1$Desocupado*(1 - indicador_dam1$Desocupado))/indicador_dam1$Desocupado_var Y_tilde[,2] &lt;- n_tilde[,2]* indicador_dam1$Desocupado # n efectivos Inactivo n_tilde[,3] &lt;- (indicador_dam1$Inactivo*(1 - indicador_dam1$Inactivo))/indicador_dam1$Inactivo_var Y_tilde[,3] &lt;- n_tilde[,3]* indicador_dam1$Inactivo ni_hat = rowSums(Y_tilde) Y_hat[,1] &lt;- ni_hat* indicador_dam1$Ocupado Y_hat[,2] &lt;- ni_hat* indicador_dam1$Desocupado Y_hat[,3] &lt;- ni_hat* indicador_dam1$Inactivo "],["validación-de-los-calculos.html", "3.10 Validación de los calculos", " 3.10 Validación de los calculos hat_p &lt;- Y_hat/rowSums(Y_hat) plot(hat_p[,1],indicador_dam1$Ocupado) plot(hat_p[,2],indicador_dam1$Desocupado) plot(hat_p[,3],indicador_dam1$Inactivo) 3.10.1 Correlación de las covariables y las estimaciones directas cor(hat_p,X_obs) ## luces_nocturnas cubrimiento_cultivo cubrimiento_urbano modificacion_humana ## [1,] 0.4920297 -0.1208481 0.4484507 0.2943970 ## [2,] 0.1401609 -0.1096543 0.1097744 0.1228389 ## [3,] -0.5400578 0.1549760 -0.4868899 -0.3347038 ## accesibilidad_hospitales accesibilidad_hosp_caminado ## [1,] 0.11274982 0.09231100 ## [2,] -0.07645658 -0.09435139 ## [3,] -0.09152536 -0.06550775 Agregando el intercepto a la matrix de covariables X1_obs &lt;- cbind(matrix(1,nrow = D,ncol = 1),X_obs) K = ncol(X1_obs) D1 &lt;- nrow(X_pred) X1_pred &lt;- cbind(matrix(1,nrow = D1,ncol = 1),X_pred) 3.10.2 Preparando argumentos para STAN sample_data &lt;- list(D = D, P = P, K = K, hat_y = Y_hat, X_obs = X1_obs, X_pred = X1_pred, D1 = D1) 3.10.3 Preparando el modelo en STAN fit2 &lt;- cmdstan_model(stan_file = &quot;01 Modelo de area/0funciones/01 Multinomial_simple_pred.stan&quot;, compile = TRUE) 3.10.4 Ejecutando el modelo en STAN fit_mcmc2 &lt;- fit2$sample( iter_sampling = 1000, iter_warmup = 1000, data = sample_data, seed = 123, chains = 4, parallel_chains = 4 ) Guardando el modelo fit_mcmc2$save_object( file = &quot;01 Modelo de area/CHL/2017/Data/fit_multinomial_con_covariable.Rds&quot;) leer el modelo previamente ejecutado fit_mcmc2 &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/fit_multinomial_con_covariable.Rds&quot;) 3.10.5 Valores estimados para beta fit_mcmc2$summary(&quot;beta&quot;) %&gt;% as.data.frame() %&gt;% tba() variable mean median sd mad q5 q95 rhat ess_bulk ess_tail beta[1,1] -2.4861 -2.4855 0.0428 0.0437 -2.5573 -2.4174 1.0023 1019.1951 2598.776 beta[2,1] -0.1591 -0.1595 0.0184 0.0183 -0.1895 -0.1280 1.0050 1324.1582 2640.008 beta[1,2] -0.0966 -0.0963 0.0899 0.0895 -0.2459 0.0518 1.0059 860.8015 1992.299 beta[2,2] -0.2346 -0.2350 0.0391 0.0391 -0.2990 -0.1709 1.0083 1097.2804 1956.711 beta[1,3] -0.2137 -0.2141 0.0509 0.0503 -0.2981 -0.1295 1.0044 816.9598 1888.151 beta[2,3] -0.0429 -0.0430 0.0220 0.0221 -0.0793 -0.0066 1.0053 977.6790 1723.405 beta[1,4] -0.1609 -0.1603 0.0748 0.0737 -0.2829 -0.0378 1.0053 1114.3069 2116.905 beta[2,4] 0.0145 0.0148 0.0324 0.0318 -0.0401 0.0681 1.0051 1052.9843 2159.417 beta[1,5] 0.2879 0.2883 0.0975 0.0977 0.1281 0.4457 1.0085 744.0500 1651.688 beta[2,5] 0.0627 0.0629 0.0423 0.0420 -0.0087 0.1331 1.0059 886.6170 1545.972 beta[1,6] 0.0298 0.0256 0.1727 0.1726 -0.2482 0.3195 1.0024 959.8096 1645.669 beta[2,6] -0.1213 -0.1216 0.0741 0.0748 -0.2412 0.0014 1.0035 1076.9747 1916.019 beta[1,7] -0.3286 -0.3231 0.6318 0.6351 -1.3925 0.7048 1.0031 1066.6718 1780.399 beta[2,7] -0.1183 -0.1166 0.2715 0.2703 -0.5650 0.3219 1.0032 1151.2476 2512.283 3.10.6 Valores estimados para la matriz de correlación fit_mcmc2$summary(&quot;Omega&quot;)%&gt;% as.data.frame() %&gt;% tba() variable mean median sd mad q5 q95 rhat ess_bulk ess_tail Omega[1,1] 1.0000 1.0000 0.0000 0.0000 1.0000 1.0000 NA NA NA Omega[2,1] 0.3437 0.3474 0.0648 0.0636 0.2327 0.4449 1.0064 732.5882 1447.365 Omega[1,2] 0.3437 0.3474 0.0648 0.0636 0.2327 0.4449 1.0064 732.5882 1447.365 Omega[2,2] 1.0000 1.0000 0.0000 0.0000 1.0000 1.0000 NA NA NA 3.10.7 Validación dela convergencia de las cadenas valores cercanos a 1 indica que las cadenas hicieron convergencia. a &lt;- fit_mcmc2$summary() mcmc_rhat(a$rhat) a %&gt;% filter(rhat&gt;1.05, !grepl(pattern = &quot;theta_pred&quot;,x =variable) ) %&gt;% arrange(desc(rhat)) %&gt;% tba() variable mean median sd mad q5 q95 rhat ess_bulk ess_tail 3.10.8 Evaluación visual de las cadenas para beta (mcmc_dens_chains(fit_mcmc2$draws(&quot;beta&quot;)) + mcmc_areas(fit_mcmc2$draws(&quot;beta&quot;)))/ mcmc_trace(fit_mcmc2$draws(&quot;beta&quot;)) 3.10.9 extrayendo las estimaciones para theta theta_temp &lt;- fit_mcmc2$summary(&quot;theta&quot;) theta_temp_pred &lt;- fit_mcmc2$summary(&quot;theta_pred&quot;) 3.10.10 Organizando los resultados en una matriz. theta_fh &lt;- matrix(theta_temp$mean, nrow = D,ncol = P,byrow = FALSE) rowSums(theta_fh) ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [149] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [186] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [223] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [260] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [297] 1 1 1 1 1 1 1 1 1 1 1 1 1 theta_fh_pred &lt;- matrix(theta_temp_pred$mean, nrow = D1,ncol = P,byrow = FALSE) rowSums(theta_fh_pred) ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3.10.10.1 Resultados informativos sobre el comportamiento del modelo. mean(indicador_dam1$Ocupado) ## [1] 0.5086088 mean(theta_fh[,1]) ## [1] 0.5092394 mean(indicador_dam1$Desocupado) ## [1] 0.0473751 mean(theta_fh[,2]) ## [1] 0.04688798 mean(indicador_dam1$Inactivo) ## [1] 0.4440161 mean(theta_fh[,3]) ## [1] 0.4438726 3.10.11 Preparando el gráfico comparativo entre la estimación dir y el modelo par(mfrow = c(1,3)) plot(theta_fh[,1],indicador_dam1$Ocupado) abline(a = 0,b = 1, col = &quot;red&quot;) plot(theta_fh[,2],indicador_dam1$Desocupado) abline(a = 0,b = 1, col = &quot;red&quot;) plot(theta_fh[,3],indicador_dam1$Inactivo) abline(a = 0,b = 1, col = &quot;red&quot;) 3.10.12 Preparando el ppc y_pred_B &lt;- fit_mcmc2$draws(variables = &quot;theta&quot;, format = &quot;matrix&quot;) rowsrandom &lt;- sample(nrow(y_pred_B), 500) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = colnames(y_pred_B),value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = colnames(y_pred_B),value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = colnames(y_pred_B),value = TRUE) y_pred1 &lt;- y_pred_B[rowsrandom,theta_1 ] y_pred2 &lt;- y_pred_B[rowsrandom,theta_2 ] y_pred3 &lt;- y_pred_B[rowsrandom,theta_3 ] ppc_dens_overlay(y = as.numeric(indicador_dam1$Ocupado), y_pred1)/ ppc_dens_overlay(y = as.numeric(indicador_dam1$Desocupado), y_pred2)/ ppc_dens_overlay(y = as.numeric(indicador_dam1$Inactivo), y_pred3) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["validación-sobre-los-resultados-del-modelo-de-área..html", "Capítulo 4 Validación sobre los resultados del modelo de área. ", " Capítulo 4 Validación sobre los resultados del modelo de área. "],["lectura-de-librerías-2.html", "4.1 Lectura de librerías", " 4.1 Lectura de librerías library(stringr) library(magrittr) library(ggplot2) library(patchwork) library(tidyverse) library(forcats) library(cmdstanr) library(bayesplot) select &lt;- dplyr::select "],["lectura-de-bases-de-datos-1.html", "4.2 Lectura de bases de datos", " 4.2 Lectura de bases de datos indicador_dam &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/indicador_dam.Rds&#39;) dam_pred &lt;- readRDS(&#39;01 Modelo de area/CHL/2017/Data/dam_pred.rds&#39;) "],["parametrizando-el-código.html", "4.3 Parametrizando el código", " 4.3 Parametrizando el código mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/&quot;,mod,&quot;.rds&quot;) out_estimacion &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_&quot;,mod,&quot;.rds&quot;) fit &lt;- readRDS(infile) "],["estimacion-directa.html", "4.4 Estimacion directa", " 4.4 Estimacion directa indicador_dam1 &lt;- indicador_dam %&gt;% filter(n_upm &gt;= 2 &amp; !is.na(Desocupado_deff)) P &lt;- 3 D &lt;- nrow(indicador_dam1) D1 &lt;- nrow(dam_pred) theta_dir &lt;- indicador_dam1 %&gt;% transmute(dam2, n = n_desocupado + n_ocupado + n_inactivo, Ocupado, Desocupado, Inactivo) "],["estimación-del-parámetro-theta.html", "4.5 Estimación del parámetro \\(\\theta\\)", " 4.5 Estimación del parámetro \\(\\theta\\) ## Estimación del modelo. theta_obs &lt;- fit$summary(&quot;theta&quot;) theta_pred &lt;- fit$summary(&quot;theta_pred&quot;) "],["ordenando-la-matriz-de-theta.html", "4.6 Ordenando la matriz de \\(\\theta\\)", " 4.6 Ordenando la matriz de \\(\\theta\\) theta_obs_ordenado &lt;- matrix(theta_obs$mean, nrow = D, ncol = P,byrow = FALSE) colnames(theta_obs_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_obs_ordenado%&lt;&gt;% as.data.frame() theta_obs_ordenado &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado) theta_pred_ordenado &lt;- matrix(theta_pred$mean, nrow = D1, ncol = P,byrow = FALSE) colnames(theta_pred_ordenado) &lt;- c(&quot;Ocupado_mod&quot;, &quot;Desocupado_mod&quot;, &quot;Inactivo_mod&quot;) theta_pred_ordenado%&lt;&gt;% as.data.frame() theta_pred_ordenado &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado) estimaciones_obs &lt;- full_join(theta_dir, bind_rows(theta_obs_ordenado,theta_pred_ordenado)) "],["estimación-del-coeficiente-de-variación.html", "4.7 Estimación del coeficiente de variación", " 4.7 Estimación del coeficiente de variación theta_obs_ordenado_sd &lt;- matrix(theta_obs$sd, nrow = D, ncol = P,byrow = FALSE) colnames(theta_obs_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_obs_ordenado_sd%&lt;&gt;% as.data.frame() theta_obs_ordenado_sd &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_sd) theta_obs_ordenado_cv &lt;- theta_obs_ordenado_sd[,-1]/theta_obs_ordenado[,-1] colnames(theta_obs_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_obs_ordenado_cv &lt;- cbind(dam2 = indicador_dam1$dam2, theta_obs_ordenado_cv) theta_pred_ordenado_sd &lt;- matrix(theta_pred$sd, nrow = D1, ncol = P,byrow = FALSE) colnames(theta_pred_ordenado_sd) &lt;- c(&quot;Ocupado_mod_sd&quot;, &quot;Desocupado_mod_sd&quot;, &quot;Inactivo_mod_sd&quot;) theta_pred_ordenado_sd%&lt;&gt;% as.data.frame() theta_pred_ordenado_sd &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_sd) theta_pred_ordenado_cv &lt;- theta_pred_ordenado_sd[,-1]/theta_pred_ordenado[,-1] colnames(theta_pred_ordenado_cv) &lt;- c(&quot;Ocupado_mod_cv&quot;, &quot;Desocupado_mod_cv&quot;, &quot;Inactivo_mod_cv&quot;) theta_pred_ordenado_cv &lt;- cbind(dam2 = dam_pred$dam2, theta_pred_ordenado_cv) "],["consolidando-los-resultados-en-una-base-de-datos..html", "4.8 Consolidando los resultados en una base de datos.", " 4.8 Consolidando los resultados en una base de datos. ############# uniendo las estimaciones, sd, cv ######### theta_obs_ordenado &lt;- full_join(theta_obs_ordenado,theta_obs_ordenado_sd) %&gt;% full_join(theta_obs_ordenado_cv) theta_pred_ordenado &lt;- full_join(theta_pred_ordenado,theta_pred_ordenado_sd) %&gt;% full_join(theta_pred_ordenado_cv) estimaciones_obs &lt;- full_join(indicador_dam1, bind_rows(theta_obs_ordenado, theta_pred_ordenado)) "],["gráfica-comparativa-entre-las-estimación-directa-y-la-estimación-resultante-del-modelo.html", "4.9 Gráfica comparativa entre las estimación directa y la estimación resultante del modelo", " 4.9 Gráfica comparativa entre las estimación directa y la estimación resultante del modelo 4.9.1 Estimación puntual p_ocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Ocupado, x = Ocupado_mod )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Ocupado&quot;)+ theme_bw(base_size = 20) p_Desocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Desocupado, x = Desocupado_mod )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot;, title = &quot;Desocupado&quot;)+ theme_bw(base_size = 20) p_Inactivo &lt;- ggplot(data = estimaciones_obs, aes(y = Inactivo, x = Inactivo_mod )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Inactivo&quot;)+ theme_bw(base_size = 20) p_ocupado|p_Desocupado|p_Inactivo 4.9.2 Error estándar. ########################################## ## Comparación de los error estándar p_ocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Ocupado_se, x = Ocupado_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Ocupado (se)&quot;)+ theme_bw(base_size = 20) p_Desocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Desocupado_se, x = Desocupado_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot;, title = &quot;Desocupado (se)&quot;)+ theme_bw(base_size = 20) p_Inactivo &lt;- ggplot(data = estimaciones_obs, aes(y = Inactivo_se, x = Inactivo_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Inactivo(se)&quot;)+ theme_bw(base_size = 20) p_ocupado + xlim(0,0.05)| p_Desocupado + xlim(0,0.05)| p_Inactivo + xlim(0,0.05) 4.9.3 Coeficiente de varianción. ########################################## ## Comparación de los cv p_ocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Ocupado_se/Ocupado, x = Ocupado_mod_cv )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Ocupado (cv)&quot;)+ theme_bw(base_size = 20) p_Desocupado &lt;- ggplot(data = estimaciones_obs, aes(y = Desocupado_se/Desocupado, x = Desocupado_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot;, title = &quot;Desocupado(cv)&quot;)+ theme_bw(base_size = 20) p_Inactivo &lt;- ggplot(data = estimaciones_obs, aes(y = Inactivo_se/Inactivo, x = Inactivo_mod_sd )) + geom_point() + geom_abline(slope = 1, intercept = 0, col = &quot;red&quot;) + labs(x = &quot;Modelo de área&quot;, y = &quot;Estimación directa&quot; , title = &quot;Inactivo(cv)&quot;)+ theme_bw(base_size = 20) p_ocupado + xlim(0,0.1)| p_Desocupado + xlim(0,0.05)| p_Inactivo + xlim(0,0.05) ### Gráficos de los ppc color_scheme_set(&quot;brightblue&quot;) theme_set(theme_bw(base_size = 15)) y_pred_B &lt;- fit$draws(variables = &quot;theta&quot;, format = &quot;matrix&quot;) rowsrandom &lt;- sample(nrow(y_pred_B), 100) theta_1&lt;- grep(pattern = &quot;1]&quot;,x = colnames(y_pred_B),value = TRUE) theta_2&lt;- grep(pattern = &quot;2]&quot;,x = colnames(y_pred_B),value = TRUE) theta_3&lt;- grep(pattern = &quot;3]&quot;,x = colnames(y_pred_B),value = TRUE) y_pred1 &lt;- y_pred_B[rowsrandom,theta_1 ] y_pred2 &lt;- y_pred_B[rowsrandom,theta_2 ] y_pred3 &lt;- y_pred_B[rowsrandom,theta_3 ] ppc_dens_overlay(y = as.numeric(theta_dir$Ocupado), y_pred1)/ ppc_dens_overlay(y = as.numeric(theta_dir$Desocupado), y_pred2)/ ppc_dens_overlay(y = as.numeric(theta_dir$Inactivo), y_pred3) 4.9.4 Convergencia de las cadenas mcmc_rhat(theta_obs$rhat) # Ordenando la base con las estimaciones directas y # predichas saveRDS(object = estimaciones_obs, file = out_estimacion) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["estimaciones-ajustadas-por-benchmark.html", "Capítulo 5 Estimaciones ajustadas por Benchmark ", " Capítulo 5 Estimaciones ajustadas por Benchmark "],["lectura-de-librerías-3.html", "5.1 Lectura de librerías", " 5.1 Lectura de librerías library(survey) library(tidyverse) library(srvyr) library(TeachingSampling) library(haven) library(sampling) "],["lectura-de-las-bases-de-datos.html", "Capítulo 6 Lectura de las bases de datos", " Capítulo 6 Lectura de las bases de datos encuesta &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/encuesta_2017.Rds&quot;) "],["parametrizando-el-código-1.html", "6.1 Parametrizando el código", " 6.1 Parametrizando el código mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_&quot;,mod,&quot;.rds&quot;) out_estimacion &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_Bench_&quot;,mod,&quot;.rds&quot;) estimaciones &lt;- readRDS(infile) "],["conteos-agregados-por-dam-y-dam2.html", "6.2 Conteos agregados por dam y dam2", " 6.2 Conteos agregados por dam y dam2 conteo_pp_dam &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/censo_mrp.rds&quot;) %&gt;% filter(edad &gt; 1) %&gt;% group_by(dam = depto, dam2 = mpio) %&gt;% summarise(pp_dam2 = sum(n)) %&gt;% add_tally(wt = pp_dam2, name = &quot;pp_dam&quot;) "],["tranformando-variables-de-la-encuesta..html", "6.3 Tranformando variables de la encuesta.", " 6.3 Tranformando variables de la encuesta. length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string =dam, width = 2, pad = &quot;0&quot;), nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = condact3 ) "],["creando-el-objeto-diseño.html", "6.4 Creando el objeto diseño", " 6.4 Creando el objeto diseño options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) "],["estimado-el-indicador.html", "6.5 Estimado el indicador", " 6.5 Estimado el indicador indicador_agregado &lt;- diseno %&gt;% group_by_at(&quot;dam&quot;) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( Ocupado = survey_ratio(numerator = (empleo == 1), denominator = 1 ), Desocupado = survey_ratio(numerator =( empleo == 2),denominator = 1 ), Inactivo = survey_ratio(numerator = (empleo == 3), denominator = 1 ) ) %&gt;% select(dam,Ocupado,Desocupado, Inactivo) "],["organizando-las-estimaciones-directas-agregadas..html", "6.6 Organizando las estimaciones directas agregadas.", " 6.6 Organizando las estimaciones directas agregadas. temp &lt;- gather(indicador_agregado, key = &quot;agregado&quot;, value = &quot;estimacion&quot;, -dam) %&gt;% mutate(nombre = paste0(&quot;dam_&quot;, dam,&quot;_&quot;, agregado)) Razon_empleo &lt;- setNames(temp$estimacion, temp$nombre) "],["benchmarking.html", "6.7 Benchmarking", " 6.7 Benchmarking names_cov &lt;- &quot;dam&quot; estimaciones_mod &lt;- estimaciones %&gt;% transmute( dam = substr(dam2,1,2), dam2,Ocupado_mod,Desocupado_mod,Inactivo_mod) %&gt;% inner_join(conteo_pp_dam ) %&gt;% mutate(wi = pp_dam2/pp_dam) Los valores no suman 1 dado que se elimina la antartida. estimaciones_mod %&gt;% group_by(dam) %&gt;% summarise(wi = sum(wi)) ## # A tibble: 16 × 2 ## dam wi ## &lt;chr&gt; &lt;dbl&gt; ## 1 01 1 ## 2 02 1 ## 3 03 1 ## 4 04 1 ## 5 05 1 ## 6 06 1 ## 7 07 1 ## 8 08 1 ## 9 09 1 ## 10 10 1 ## 11 11 1 ## 12 12 0.999 ## 13 13 1 ## 14 14 1 ## 15 15 1 ## 16 16 1 "],["seleccionado-variables.html", "6.8 Seleccionado variables", " 6.8 Seleccionado variables estimaciones_mod %&lt;&gt;% fastDummies::dummy_cols(select_columns = names_cov, remove_selected_columns = FALSE) "],["creando-las-dummys.html", "6.9 creando las dummys", " 6.9 creando las dummys Xdummy &lt;- estimaciones_mod %&gt;% select(matches(&quot;dam_&quot;)) %&gt;% mutate_at(vars(matches(&quot;_\\\\d&quot;)) , list(Ocupado = function(x) x*estimaciones_mod$Ocupado_mod, Desocupado = function(x) x*estimaciones_mod$Desocupado_mod, Inactivo = function(x) x*estimaciones_mod$Inactivo_mod)) %&gt;% select((matches(&quot;Ocupado|Desocupado|Inactivo&quot;))) "],["validación-de-la-concordancia-de-los-nombre.html", "6.10 Validación de la concordancia de los nombre", " 6.10 Validación de la concordancia de los nombre colnames(Xdummy) == names(Razon_empleo) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [46] TRUE TRUE TRUE data.frame(Modelo = colSums(Xdummy*estimaciones_mod$wi), Estimacion_encuesta = Razon_empleo) ## Modelo Estimacion_encuesta ## dam_01_Ocupado 0.57696754 0.58485184 ## dam_02_Ocupado 0.55306546 0.55614508 ## dam_03_Ocupado 0.52430985 0.52457151 ## dam_04_Ocupado 0.47094481 0.46969196 ## dam_05_Ocupado 0.51749483 0.51762640 ## dam_06_Ocupado 0.52125693 0.52346473 ## dam_07_Ocupado 0.51514726 0.51437848 ## dam_08_Ocupado 0.48432594 0.47706114 ## dam_09_Ocupado 0.49177321 0.49032170 ## dam_10_Ocupado 0.53122452 0.53233998 ## dam_11_Ocupado 0.60816182 0.61801704 ## dam_12_Ocupado 0.59155423 0.59231614 ## dam_13_Ocupado 0.59449276 0.60401104 ## dam_14_Ocupado 0.50671532 0.50601851 ## dam_15_Ocupado 0.50983847 0.50997160 ## dam_16_Ocupado 0.50083251 0.50230442 ## dam_01_Desocupado 0.04760872 0.04865991 ## dam_02_Desocupado 0.05190692 0.05561626 ## dam_03_Desocupado 0.05080028 0.05318520 ## dam_04_Desocupado 0.06240013 0.06401381 ## dam_05_Desocupado 0.05464411 0.05621727 ## dam_06_Desocupado 0.04160122 0.04114200 ## dam_07_Desocupado 0.03990747 0.03870429 ## dam_08_Desocupado 0.05770353 0.06006990 ## dam_09_Desocupado 0.04815869 0.05009673 ## dam_10_Desocupado 0.04126619 0.04105318 ## dam_11_Desocupado 0.03429950 0.03257809 ## dam_12_Desocupado 0.03846971 0.03760152 ## dam_13_Desocupado 0.05184454 0.05278045 ## dam_14_Desocupado 0.04587066 0.04790803 ## dam_15_Desocupado 0.06635795 0.06758221 ## dam_16_Desocupado 0.04297262 0.04368049 ## dam_01_Inactivo 0.37542374 0.36648824 ## dam_02_Inactivo 0.39502762 0.38823866 ## dam_03_Inactivo 0.42488987 0.42224330 ## dam_04_Inactivo 0.46665506 0.46629423 ## dam_05_Inactivo 0.42786106 0.42615633 ## dam_06_Inactivo 0.43714184 0.43539327 ## dam_07_Inactivo 0.44494528 0.44691723 ## dam_08_Inactivo 0.45797052 0.46286896 ## dam_09_Inactivo 0.46006810 0.45958157 ## dam_10_Inactivo 0.42750928 0.42660684 ## dam_11_Inactivo 0.35753868 0.34940487 ## dam_12_Inactivo 0.36901740 0.37008234 ## dam_13_Inactivo 0.35366270 0.34320851 ## dam_14_Inactivo 0.44741402 0.44607346 ## dam_15_Inactivo 0.42380358 0.42244619 ## dam_16_Inactivo 0.45619487 0.45401509 "],["idenficando-valores-por-cátegoria..html", "6.11 Idenficando valores por cátegoria.", " 6.11 Idenficando valores por cátegoria. names_ocupado &lt;- grep(pattern = &quot;_O&quot;, x = colnames(Xdummy),value = TRUE) names_descupados &lt;- grep(pattern = &quot;_D&quot;, x = colnames(Xdummy),value = TRUE) names_inactivo &lt;- grep(pattern = &quot;_I&quot;, x = colnames(Xdummy),value = TRUE) 6.11.1 Ocupado gk_ocupado &lt;- calib(Xs = Xdummy[,names_ocupado], d = estimaciones_mod$wi, total = Razon_empleo[names_ocupado], method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_ocupado], d =estimaciones_mod$wi, total = Razon_empleo[names_ocupado], g = gk_ocupado,) ## $message ## [1] &quot;the calibration is done&quot; ## ## $result ## [1] TRUE ## ## $value ## [1] 1e-06 summary(gk_ocupado) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.9827 0.9985 1.0005 1.0021 1.0043 1.0191 6.11.2 Desocupado gk_desocupado &lt;- calib(Xs = Xdummy[,names_descupados], d = estimaciones_mod$wi, total = Razon_empleo[names_descupados], method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_descupados], d =estimaciones_mod$wi, total = Razon_empleo[names_descupados], g = gk_desocupado,) ## $message ## [1] &quot;the calibration is done&quot; ## ## $result ## [1] TRUE ## ## $value ## [1] 1e-06 summary(gk_desocupado) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.9387 0.9946 1.0171 1.0143 1.0317 1.0983 "],["inactivo.html", "6.12 Inactivo", " 6.12 Inactivo gk_Inactivo &lt;- calib(Xs = Xdummy[,names_inactivo], d = estimaciones_mod$wi, total = Razon_empleo[names_inactivo], method=&quot;linear&quot;,max_iter = 5000,) checkcalibration(Xs = Xdummy[,names_inactivo], d =estimaciones_mod$wi, total = Razon_empleo[names_inactivo], g = gk_Inactivo,) ## $message ## [1] &quot;the calibration is done&quot; ## ## $result ## [1] TRUE ## ## $value ## [1] 1e-06 summary(gk_Inactivo) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.9610 0.9942 0.9963 0.9935 0.9992 1.0137 validando los \\(gk\\)’s de forma visual. par(mfrow = c(1,3)) hist(gk_ocupado) hist(gk_desocupado) hist(gk_Inactivo) 6.12.1 Creando las estimaciones Benchmark estimacionesBench &lt;- estimaciones_mod %&gt;% mutate(gk_ocupado, gk_desocupado, gk_Inactivo) %&gt;% transmute( dam, dam2, wi,gk_ocupado, gk_desocupado, gk_Inactivo, Ocupado_Bench = Ocupado_mod*gk_ocupado, Desocupado_Bench = Desocupado_mod*gk_desocupado, Inactivo_Bench = Inactivo_mod*gk_Inactivo ) #############################33 Comparando resultados del Benchmarking estimacionesBench %&gt;% group_by(dam) %&gt;% summarise(Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) %&gt;% inner_join(indicador_agregado) %&gt;% View() estimaciones &lt;- inner_join(estimaciones,estimacionesBench) Ordenando la base con las estimaciones directas y predichas saveRDS(object = estimaciones, file = out_estimacion) knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["validación-visual-del-benchmark.html", "Capítulo 7 Validación visual del Benchmark ", " Capítulo 7 Validación visual del Benchmark "],["lectura-de-librerias.html", "7.1 Lectura de librerias", " 7.1 Lectura de librerias library(plotly) library(dplyr) library(tidyr) library(forcats) library(survey) library(srvyr) library(haven) library(stringr) library(patchwork) "],["lectura-de-encuesta..html", "7.2 Lectura de encuesta.", " 7.2 Lectura de encuesta. encuesta &lt;- readRDS(&quot;01 Modelo de area/CHL/2017/Data/encuesta_2017.Rds&quot;) mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_Bench_&quot;,mod,&quot;.rds&quot;) estimaciones &lt;- readRDS(infile) estimaciones %&gt;% filter(is.na(dam)) ## # A tibble: 0 × 34 ## # … with 34 variables: dam2 &lt;chr&gt;, n_upm &lt;int&gt;, n_ocupado &lt;int&gt;, ## # n_desocupado &lt;int&gt;, n_inactivo &lt;int&gt;, Ocupado &lt;dbl&gt;, Ocupado_se &lt;dbl&gt;, ## # Ocupado_var &lt;dbl&gt;, Ocupado_deff &lt;dbl&gt;, Desocupado &lt;dbl&gt;, ## # Desocupado_se &lt;dbl&gt;, Desocupado_var &lt;dbl&gt;, Desocupado_deff &lt;dbl&gt;, ## # Inactivo &lt;dbl&gt;, Inactivo_se &lt;dbl&gt;, Inactivo_var &lt;dbl&gt;, Inactivo_deff &lt;dbl&gt;, ## # Ocupado_mod &lt;dbl&gt;, Desocupado_mod &lt;dbl&gt;, Inactivo_mod &lt;dbl&gt;, ## # Ocupado_mod_sd &lt;dbl&gt;, Desocupado_mod_sd &lt;dbl&gt;, Inactivo_mod_sd &lt;dbl&gt;, … "],["estimación-agregada.html", "7.3 Estimación agregada", " 7.3 Estimación agregada ############## Estimación agregada ###################### estimaciones_agregada &lt;- estimaciones %&gt;% group_by(dam) %&gt;% summarise( Ocupado_mod = sum(wi*Ocupado_mod), Desocupado_mod = sum(wi*Desocupado_mod), Inactivo_mod = sum(wi*Inactivo_mod), Ocupado_Bench = sum(wi*Ocupado_Bench), Desocupado_Bench = sum(wi*Desocupado_Bench), Inactivo_Bench = sum(wi*Inactivo_Bench)) "],["creación-de-objeto-diseno.html", "7.4 Creación de objeto diseno", " 7.4 Creación de objeto diseno length_upm &lt;- max(nchar(encuesta[[&quot;_upm&quot;]])) length_estrato &lt;- max(nchar(encuesta[[&quot;_estrato&quot;]])) encuesta &lt;- encuesta %&gt;% transmute( dam = as_factor(dam_ee,levels = &quot;values&quot;), dam = str_pad(string =dam, width = 2, pad = &quot;0&quot;), nombre_dam = as_factor(dam_ee,levels = &quot;labels&quot;), upm = str_pad(string = `_upm`, width = length_upm, pad = &quot;0&quot;), estrato = str_pad(string = `_estrato`, width = length_estrato , pad = &quot;0&quot;), fep = `_fep`, empleo = condact3 ) options(survey.lonely.psu= &#39;adjust&#39; ) diseno &lt;- encuesta %&gt;% as_survey_design( strata = estrato, ids = upm, weights = fep, nest=T ) "],["estimación-del-indicador.html", "7.5 Estimación del indicador", " 7.5 Estimación del indicador indicador_agregado &lt;- diseno %&gt;% group_by_at(&quot;dam&quot;) %&gt;% filter(empleo %in% c(1:3)) %&gt;% summarise( nd = unweighted(n()), Ocupado = survey_ratio(numerator = (empleo == 1), denominator = 1,vartype = c(&quot;ci&quot;), level = 0.95 ), Desocupado = survey_ratio(numerator =( empleo == 2),denominator = 1, vartype = c(&quot;ci&quot;), level = 0.95 ), Inactivo = survey_ratio(numerator = (empleo == 3), denominator = 1, vartype = c(&quot;ci&quot;), level = 0.95 ) ) data_plot &lt;- left_join(estimaciones_agregada, indicador_agregado) "],["creando-los-plot-uni.html", "7.6 Creando los plot uni", " 7.6 Creando los plot uni 7.6.1 Ocupado temp_ocupado &lt;- data_plot %&gt;% select(dam,nd, starts_with(&quot;Ocupado&quot;)) temp_ocupado_1 &lt;- temp_ocupado %&gt;% select(-Ocupado_low, -Ocupado_upp) %&gt;% gather(key = &quot;Estimacion&quot;,value = &quot;value&quot;, -nd,-dam) %&gt;% mutate(Estimacion = case_when(Estimacion == &quot;Ocupado_mod&quot; ~ &quot;Modelo de área&quot;, Estimacion == &quot;Ocupado_Bench&quot; ~ &quot;Modelo de área (bench)&quot;, Estimacion == &quot;Ocupado&quot;~ &quot;Directo&quot;)) lims_IC_ocupado &lt;- temp_ocupado %&gt;% select(dam,nd,value = Ocupado,Ocupado_low, Ocupado_upp) %&gt;% mutate(Estimacion = &quot;Directo&quot;) p_ocupado &lt;- ggplot(temp_ocupado_1, aes( x = fct_reorder2(dam, dam, nd), y = value, shape = Estimacion, color = Estimacion )) + geom_errorbar( data = lims_IC_ocupado, aes(ymin = Ocupado_low , ymax = Ocupado_upp, x = dam), width = 0.2, linewidth = 1 ) + geom_jitter(size = 3)+ labs(x = &quot;Dam&quot;, title = &quot;Ocupado&quot;) 7.6.2 Desocupado temp_Desocupado &lt;- data_plot %&gt;% select(dam,nd, starts_with(&quot;Desocupado&quot;)) temp_Desocupado_1 &lt;- temp_Desocupado %&gt;% select(-Desocupado_low, -Desocupado_upp) %&gt;% gather(key = &quot;Estimacion&quot;,value = &quot;value&quot;, -nd,-dam) %&gt;% mutate(Estimacion = case_when(Estimacion == &quot;Desocupado_mod&quot; ~ &quot;Modelo de área&quot;, Estimacion == &quot;Desocupado_Bench&quot; ~ &quot;Modelo de área (bench)&quot;, Estimacion == &quot;Desocupado&quot;~ &quot;Directo&quot;)) lims_IC_Desocupado &lt;- temp_Desocupado %&gt;% select(dam,nd,value = Desocupado,Desocupado_low, Desocupado_upp) %&gt;% mutate(Estimacion = &quot;Directo&quot;) p_Desocupado &lt;- ggplot(temp_Desocupado_1, aes( x = fct_reorder2(dam, dam, nd), y = value, shape = Estimacion, color = Estimacion )) + geom_errorbar( data = lims_IC_Desocupado, aes(ymin = Desocupado_low , ymax = Desocupado_upp, x = dam), width = 0.2, linewidth = 1 ) + geom_jitter(size = 3)+ labs(x = &quot;Dam&quot;, title = &quot;Desocupado&quot;) 7.6.3 Inactivo temp_Inactivo &lt;- data_plot %&gt;% select(dam,nd, starts_with(&quot;Inactivo&quot;)) temp_Inactivo_1 &lt;- temp_Inactivo %&gt;% select(-Inactivo_low, -Inactivo_upp) %&gt;% gather(key = &quot;Estimacion&quot;,value = &quot;value&quot;, -nd,-dam) %&gt;% mutate(Estimacion = case_when(Estimacion == &quot;Inactivo_mod&quot; ~ &quot;Modelo de área&quot;, Estimacion == &quot;Inactivo_Bench&quot; ~ &quot;Modelo de área (bench)&quot;, Estimacion == &quot;Inactivo&quot;~ &quot;Directo&quot;)) lims_IC_Inactivo &lt;- temp_Inactivo %&gt;% select(dam,nd,value = Inactivo,Inactivo_low, Inactivo_upp) %&gt;% mutate(Estimacion = &quot;Directo&quot;) p_Inactivo &lt;- ggplot(temp_Inactivo_1, aes( x = fct_reorder2(dam, dam, nd), y = value, shape = Estimacion, color = Estimacion )) + geom_errorbar( data = lims_IC_Inactivo, aes(ymin = Inactivo_low , ymax = Inactivo_upp, x = dam), width = 0.2, linewidth = 1 ) + geom_jitter(size = 3)+ labs(x = &quot;Dam&quot;, title = &quot;Inactivo&quot;) p_ocupado/p_Desocupado/p_Inactivo knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 4.2.2 tba &lt;- function(dat, cap = NA){ kable(dat, format = &quot;html&quot;, digits = 4, caption = cap) %&gt;% kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F)%&gt;% kable_classic(full_width = F, html_font = &quot;Arial Narrow&quot;) } "],["mapas-de-resultados.html", "Capítulo 8 Mapas de resultados ", " Capítulo 8 Mapas de resultados "],["lectura-de-librerías-4.html", "8.1 Lectura de librerías", " 8.1 Lectura de librerías library(tidyverse) library(magrittr) library(patchwork) library(sp) library(sf) library(tmap) library(RColorBrewer) library(maptools) library(DescTools) "],["parametrizando-el-código-2.html", "8.2 Parametrizando el código", " 8.2 Parametrizando el código mod &lt;- &quot;fit_multinomial_con_covariable&quot; infile &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Data/estimaciones_Bench_&quot;,mod,&quot;.rds&quot;) outOcupado &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Ocupados_&quot;,mod,&quot;.pdf&quot;) outDesocupado &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Desocupados_&quot;,mod,&quot;.pdf&quot;) outInactivo &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Inactivo_&quot;,mod,&quot;.pdf&quot;) outMosaico &lt;- paste0(&quot;01 Modelo de area/CHL/2017/Output/Mosaico_&quot;,mod,&quot;.png&quot;) estimaciones &lt;- readRDS(infile) "],["lectura-de-shapefile.html", "8.3 Lectura de shapefile", " 8.3 Lectura de shapefile ## leer shape del pais ShapeSAE &lt;- read_sf(&quot;01 Modelo de area/CHL/2017/ShapeDeptoCHL/comunas.shp&quot;) ShapeSAE %&lt;&gt;% mutate(dam2 = str_pad( string = cod_comuna, width = 5, pad = &quot;0&quot; ), dam = str_pad( string = codregion, width = 2, pad = &quot;0&quot; ) ) %&gt;% filter(dam != &quot;00&quot;, !dam2 %in% c(&quot;05201&quot;, &quot;13603&quot;)) # 13603: Isla de Isla de Maipo # 05201: Isla de Pascua # ShapeSAE %&gt;% as.data.frame() %&gt;% select(dam2,dam,Comuna) %&gt;% # view() "],["definición-del-mapa-con-tmap.html", "8.4 Definición del mapa con tmap", " 8.4 Definición del mapa con tmap ######################################### P1_empleo &lt;- tm_shape(ShapeSAE %&gt;% inner_join(estimaciones)) brks_ocupado &lt;- seq(0.3,0.8,0.1) brks_desocupado &lt;- seq(0,0.2,0.05) brks_inactivo &lt;- seq(0.15,0.6, 0.09) 8.4.1 Creando mapa de ocupados Mapa_ocupado &lt;- P1_empleo + tm_fill(&quot;Ocupado_mod&quot;, breaks = brks_ocupado, title = &quot;Ocupado&quot;, palette = &quot;-Blues&quot;) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3 ) Guardando el mapa de coupados tmap_save( Mapa_ocupado, outOcupado, width = 6920, height = 4080, asp = 0 ) 8.4.2 Creando mapa de desocupados Mapa_desocupado &lt;- P1_empleo + tm_fill( &quot;Desocupado_mod&quot;, breaks = brks_desocupado, title = &quot;Desocupado&quot;, palette = &quot;YlOrRd&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Guardando el mapa de desocupado tmap_save( Mapa_desocupado, outDesocupado, width = 6920, height = 4080, asp = 0 ) 8.4.3 Creando mapa de inactivo Mapa_Inactivo &lt;- P1_empleo + tm_fill( &quot;Inactivo_mod&quot;, title = &quot;Inactivo&quot;, breaks = brks_inactivo, palette = &quot;YlGn&quot; ) + tm_layout( legend.only = FALSE, legend.height = -0.5, legend.width = -0.5, asp = 1.5, legend.text.size = 3, legend.title.size = 3) Guardando el mapa de inactivo tmap_save( Mapa_Inactivo, outInactivo, width = 6920, height = 4080, asp = 0 ) creando un mosaico. mosaico &lt;- tmap_arrange(Mapa_Inactivo, Mapa_ocupado,Mapa_desocupado,ncol = 3, nrow = 1 ) guardar mosaico tmap_save( mosaico, outMosaico, width = 8920, height = 4080, asp = 0 ) knitr::include_graphics(&quot;01 Modelo de area/CHL/2017/Output/Mosaico_fit_multinomial_con_covariable.png&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
